<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-02-24 Sat 00:18 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>cpp-notes</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">cpp-notes</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga07a5d9">1. Compiler</a>
<ul>
<li><a href="#orgb4c2034">1.1. Optimizations</a></li>
<li><a href="#org69fe851">1.2. Extensions</a></li>
<li><a href="#org4aab9aa">1.3. Enable Warnings</a></li>
<li><a href="#orge7c7807">1.4. Version Code Names</a></li>
</ul>
</li>
<li><a href="#orgec7925c">2. Basics</a>
<ul>
<li><a href="#orgdb030d4">2.1. Statements</a></li>
<li><a href="#org7111ec8">2.2. Variable Assignment</a>
<ul>
<li><a href="#org11daaa5">2.2.1. The Maybe Unused Attribute</a></li>
</ul>
</li>
<li><a href="#orgd6b7b06">2.3. Implementation Defined Behavior</a></li>
<li><a href="#org07cccd7">2.4. Identifier Naming Conventions</a></li>
<li><a href="#orgb477874">2.5. Literals and Operators</a></li>
<li><a href="#org2100fed">2.6. Expressions</a></li>
</ul>
</li>
<li><a href="#org93778f3">3. Functions and Files</a>
<ul>
<li><a href="#org05a4004">3.1. Return values</a></li>
<li><a href="#org679130c">3.2. Parameters and Arguments</a></li>
<li><a href="#org3186f55">3.3. The One Definition Rule</a></li>
<li><a href="#org032874e">3.4. Namespaces</a></li>
<li><a href="#org9c7ae19">3.5. Preprocessor</a>
<ul>
<li><a href="#org4129e2b">3.5.1. Preprocessor Directives</a></li>
<li><a href="#orgd941a90">3.5.2. Header Files</a></li>
<li><a href="#org2e49f3e">3.5.3. Header Guards</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0950472">4. Debugging</a>
<ul>
<li><a href="#orgecd61c4">4.1. Some Debugging Tactics</a></li>
<li><a href="#orgdd0042a">4.2. Using a debugger</a>
<ul>
<li><a href="#org617ba5d">4.2.1. Step Into</a></li>
<li><a href="#orgc9277f1">4.2.2. Step Over</a></li>
<li><a href="#orgdeb7766">4.2.3. Step Out</a></li>
<li><a href="#org95b604c">4.2.4. Run to Cursor</a></li>
<li><a href="#orgc7d9693">4.2.5. Continue</a></li>
<li><a href="#orge76b543">4.2.6. Breakpoints</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org525cfb5">5. Data Types and Related Stuff</a>
<ul>
<li><a href="#org8429077">5.1. Standard Integers</a></li>
<li><a href="#orge6cca15">5.2. <code>size_t</code></a></li>
<li><a href="#orga4a0aa6">5.3. Floating Point Precision</a></li>
<li><a href="#orge3785df">5.4. Rounding Errors in Decimals</a></li>
<li><a href="#orgeef7771">5.5. NaN and Infinity</a></li>
<li><a href="#orgb0dc99e">5.6. Boolean Values</a></li>
<li><a href="#org63aa26e">5.7. Explicit Type Conversions</a></li>
<li><a href="#orgb365da9">5.8. Hexadecimal, Octal and Binary Literals</a></li>
</ul>
</li>
<li><a href="#org0b5c3fe">6. Constants and Strings</a>
<ul>
<li><a href="#orgb769f53">6.1. Constant Expressions</a></li>
<li><a href="#orgf059c20">6.2. The Inline Keyword</a></li>
<li><a href="#org11a99a4">6.3. <code>constexpr</code> and <code>consteval</code></a></li>
<li><a href="#orgcf292cd">6.4. Immediate Functions</a></li>
<li><a href="#org1ec837b">6.5. Strings</a></li>
<li><a href="#org7b1aba7">6.6. <code>std::string_view</code></a></li>
</ul>
</li>
<li><a href="#org10c356e">7. Operators</a>
<ul>
<li><a href="#orgbd237c0">7.1. Binary Division Operator</a></li>
<li><a href="#orgf9b9d12">7.2. Comma Operator</a></li>
<li><a href="#org291ed14">7.3. Comparing floating points</a></li>
</ul>
</li>
<li><a href="#org913e616">8. Bit Manipulation</a>
<ul>
<li><a href="#org1dc0b6e">8.1. Key Member Functions</a>
<ul>
<li><a href="#org97984c3">8.1.1. <code>test(position)</code></a></li>
<li><a href="#org920d011">8.1.2. <code>set(position)</code></a></li>
<li><a href="#org434dfa4">8.1.3. <code>reset(position)</code></a></li>
<li><a href="#org54c07e0">8.1.4. <code>flip(position)</code></a></li>
<li><a href="#org490b122">8.1.5. <code>size()</code></a></li>
<li><a href="#org041d359">8.1.6. <code>count()</code></a></li>
<li><a href="#orgbf12839">8.1.7. <code>any()</code></a></li>
<li><a href="#org225c141">8.1.8. <code>none()</code></a></li>
<li><a href="#org1f48879">8.1.9. <code>all()</code></a></li>
</ul>
</li>
<li><a href="#org3a418ff">8.2. Bitwise Operators</a></li>
<li><a href="#org0063ca8">8.3. Bit Masks</a>
<ul>
<li><a href="#orgc7c8d11">8.3.1. Testing Bits using Masks</a></li>
<li><a href="#orgf5934d3">8.3.2. Setting and Resetting Bits using Masks</a></li>
</ul>
</li>
<li><a href="#org5904666">8.4. Example Hex Colour to RGBA Colour</a></li>
<li><a href="#org037ac6c">8.5. Two's Complement</a></li>
</ul>
</li>
<li><a href="#org815ee1e">9. Namespaces</a>
<ul>
<li><a href="#org7322e4f">9.1. Namespace Aliases</a></li>
</ul>
</li>
<li><a href="#orga849d93">10. Scope, Duration and Lifetime</a>
<ul>
<li><a href="#orgae3155f">10.1. Name Hiding (Shadowing)</a></li>
<li><a href="#org8e21aff">10.2. Internal Linkage</a></li>
<li><a href="#org6362e65">10.3. External Linkage</a></li>
<li><a href="#orgd17f1a8">10.4. Non-constant Global Variables are Evil</a></li>
<li><a href="#orge798684">10.5. Sharing Global Variables Across Files</a></li>
<li><a href="#org6f13169">10.6. Global Constants as Inline Variables</a></li>
<li><a href="#org775fb13">10.7. Static on local variables</a></li>
<li><a href="#org5a9ce1b">10.8. Summary</a></li>
</ul>
</li>
<li><a href="#orgab75ff8">11. Using Declarations</a>
<ul>
<li><a href="#orgc95ed5d">11.1. Qualified and unqualified names</a></li>
<li><a href="#orgcf0c139">11.2. Using-declarations</a></li>
<li><a href="#org40e5df7">11.3. Using-directives</a></li>
</ul>
</li>
<li><a href="#orgf934a29">12. Control Flow</a>
<ul>
<li><a href="#org9f90c65">12.1. Null Statements</a></li>
<li><a href="#org5626bf7">12.2. <code>constexpr</code> if statements</a></li>
<li><a href="#org6ec5a12">12.3. The <code>[[fallthrough]]</code> attribute</a></li>
<li><a href="#org1680da7">12.4. Halting Programs</a></li>
</ul>
</li>
<li><a href="#orgab0dc68">13. Randomness</a>
<ul>
<li><a href="#orgd3aef04">13.1. Built-in PRNGs in C++</a></li>
</ul>
</li>
<li><a href="#org450ab08">14. Software Testing</a>
<ul>
<li><a href="#org185e6d0">14.1. Informal Testing</a></li>
<li><a href="#orgcf26668">14.2. Code Coverage</a></li>
<li><a href="#org9f77478">14.3. Symantic Errors</a></li>
<li><a href="#orga465ee6">14.4. Detecting and Handling Errors</a></li>
<li><a href="#org3afda62">14.5. Handling String Input</a>
<ul>
<li><a href="#org825b638">14.5.1. Error Case 1: Extraction succeeds but input is meaningless</a></li>
<li><a href="#org493f623">14.5.2. Error Case 2: Input buffer already had some characters</a></li>
<li><a href="#org00c86eb">14.5.3. Error Case 3: Extraction fails and program goes in an infinite loop</a></li>
</ul>
</li>
<li><a href="#orge032d14">14.6. Assertions</a>
<ul>
<li><a href="#orgc750860">14.6.1. Assert</a></li>
<li><a href="#orgd3f9b64">14.6.2. Static Assert</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3bc52a5">15. Type Conversions, Type Aliases, Type Deduction</a>
<ul>
<li><a href="#orgf0658f0">15.1. Implicit Type Conversions</a>
<ul>
<li><a href="#org01e9d44">15.1.1. Numeric Promotions</a></li>
</ul>
</li>
<li><a href="#org2a33355">15.2. Narrowing Conversions</a></li>
<li><a href="#org3bd09d9">15.3. Type Aliases</a></li>
<li><a href="#org46bdd33">15.4. Type Deduction</a></li>
</ul>
</li>
<li><a href="#org88b1616">16. Function Overloading</a>
<ul>
<li><a href="#orgedcd7b8">16.1. Function Overload Differentiation</a></li>
<li><a href="#org976c85f">16.2. Resolving Overloaded Function Calls</a></li>
<li><a href="#orga4c7ec9">16.3. Deleting Functions</a></li>
<li><a href="#org94ec698">16.4. Default Arguments</a></li>
</ul>
</li>
<li><a href="#org1d2684e">17. Function Templates</a>
<ul>
<li><a href="#orgdbd7f4b">17.1. Forward Declaring Function Templates</a></li>
<li><a href="#org7e277bb">17.2. Including Function Templates</a></li>
<li><a href="#org349d745">17.3. Abbreviated Function Templates</a></li>
<li><a href="#org8827b30">17.4. Non-type Template Parameters</a></li>
</ul>
</li>
<li><a href="#org6a0614f">18. References</a>
<ul>
<li><a href="#orga74661b">18.1. Lvalue and Rvalue Expressions</a></li>
<li><a href="#org48b78ae">18.2. Lvalue References</a></li>
<li><a href="#org27f2060">18.3. Dangling References</a></li>
<li><a href="#orgbeab874">18.4. Lvalue references to const</a></li>
<li><a href="#org030e4a0">18.5. Pass Values by Reference To Functions</a>
<ul>
<li><a href="#org3de749c">18.5.1. </a></li>
</ul>
</li>
<li><a href="#org7309e0e">18.6. Return by Reference</a></li>
<li><a href="#org28d3ad6">18.7. In-Out Parameters</a></li>
</ul>
</li>
<li><a href="#orgb5cf7f7">19. Pointers</a>
<ul>
<li><a href="#orgb45e8f8">19.1. Dangling Pointers</a></li>
<li><a href="#org73a7dfd">19.2. Null Pointers</a></li>
<li><a href="#org320fead">19.3. Pointer to a Const</a></li>
<li><a href="#orgf36a3e1">19.4. Const Pointers</a></li>
<li><a href="#org5585b3b">19.5. Const Pointer to a Const Variable</a></li>
<li><a href="#orge2a4035">19.6. Passing Values to Functions By Address</a></li>
<li><a href="#orgd90ff5b">19.7. Setting Optional Parameters in Functions</a></li>
<li><a href="#orgf7da16a">19.8. Top Level and Low Level Consts</a></li>
<li><a href="#org27c7fad">19.9. Auto and Pointers</a>
<ul>
<li><a href="#org828d5d7">19.9.1. <span class="todo TODO">TODO</span> Read chapter 12.14 again!</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8e3bc3c">20. User Defined Types</a>
<ul>
<li><a href="#org72d6a3b">20.1. Enumeration Types</a>
<ul>
<li><a href="#org5cb2764">20.1.1. Unscoped Enumerations</a></li>
<li><a href="#orgbc1f85d">20.1.2. Scoped Enumerations</a></li>
</ul>
</li>
<li><a href="#orgd794fe3">20.2. Class Types</a>
<ul>
<li><a href="#org4acaaa1">20.2.1. Structs</a></li>
<li><a href="#orgc4e01bf">20.2.2. Class Templates on Structs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd6ce347">21. Object Oriented Programming</a>
<ul>
<li><a href="#orgdd33d85">21.1. Classes</a>
<ul>
<li><a href="#orgf4d0bb3">21.1.1. Introduction</a></li>
<li><a href="#org0fbdaac">21.1.2. Member Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga07a5d9" class="outline-2">
<h2 id="orga07a5d9"><span class="section-number-2">1.</span> Compiler</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgb4c2034" class="outline-3">
<h3 id="orgb4c2034"><span class="section-number-3">1.1.</span> Optimizations</h3>
<div class="outline-text-3" id="text-1-1">
<p>
You can use the <code>-ggdb</code> flag to compile in debug mode and <code>-O2 -DNDEBUG</code> to compile with the best optimizations.
</p>
</div>
</div>
<div id="outline-container-org69fe851" class="outline-3">
<h3 id="org69fe851"><span class="section-number-3">1.2.</span> Extensions</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Disable compiler-specific extensions and strictly follow the C++ standard by adding the <code>-pedantic-errors</code> flag.
</p>
</div>
</div>
<div id="outline-container-org4aab9aa" class="outline-3">
<h3 id="org4aab9aa"><span class="section-number-3">1.3.</span> Enable Warnings</h3>
<div class="outline-text-3" id="text-1-3">
<p>
You should enable warnings for the best learning experience.
Enable them using- <code>-Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion</code>
To treat warnings as errors, add <code>-Werror</code> flag.
</p>
</div>
</div>
<div id="outline-container-orge7c7807" class="outline-3">
<h3 id="orge7c7807"><span class="section-number-3">1.4.</span> Version Code Names</h3>
<div class="outline-text-3" id="text-1-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Version</td>
<td class="org-left">Code Name Before Release</td>
</tr>

<tr>
<td class="org-left">C++11</td>
<td class="org-left">c++1x</td>
</tr>

<tr>
<td class="org-left">C++14</td>
<td class="org-left">c++1y</td>
</tr>

<tr>
<td class="org-left">C++17</td>
<td class="org-left">c++1z</td>
</tr>

<tr>
<td class="org-left">C++20</td>
<td class="org-left">c++2a</td>
</tr>

<tr>
<td class="org-left">C++23</td>
<td class="org-left">c++2b</td>
</tr>
</tbody>
</table>

<p>
Compiler flags are <code>-std=c++11</code>, <code>-std=c++14</code>, <code>-std=c++17</code>, <code>-std=c++20</code>, <code>-std=c++2b</code>
</p>
</div>
</div>
</div>
<div id="outline-container-orgec7925c" class="outline-2">
<h2 id="orgec7925c"><span class="section-number-2">2.</span> Basics</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgdb030d4" class="outline-3">
<h3 id="orgdb030d4"><span class="section-number-3">2.1.</span> Statements</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A statement is an instruction in a computer program that tells the computer to perform an action.
</p>
<ol class="org-ol">
<li>Declaration Statements</li>
<li>Jump Statements</li>
<li>Expression Statements</li>
<li>Compound Statements</li>
<li>Selection Statements (Conditionals)</li>
<li>Iteration Statements</li>
<li>Try Blocks</li>
</ol>
</div>
</div>
<div id="outline-container-org7111ec8" class="outline-3">
<h3 id="org7111ec8"><span class="section-number-3">2.2.</span> Variable Assignment</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>Assignment
When variables are assigned using the <code>=</code> operator, value on the right hand side is copied to the variable on the left hand side, known as <i>copy assignment</i>.</li>
<li>Initialization
<ol class="org-ol">
<li>Default Initialization
No initial value is provided.</li>
<li>Copy Initialization
Initializer is provided after equal sign.
Use of this is discouraged because it is considered inefficient.
<code>int a = 5;</code></li>
<li>Direct Initialization
Initializer is provided inside parenthesis.
Use of this is also discouraged, because it is confusing to read and is superseded by list initialization.
<code>int a(5);</code></li>
<li><p>
List Initialization
Modern way. It does not allow narrow conversions because narrow conversions can cause data loss. Introduced in C++17.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-1">{</span>5<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">direct list initialization</span>
<span class="org-type">int</span> <span class="org-variable-name">a</span> = <span class="org-rainbow-delimiters-depth-1">{</span>5<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">copy list initialization</span>
<span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">value list initialization</span>
<span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">{</span>4.5<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">ERROR while a(4.5) or a = 4.5 won't give any error</span>
</pre>
</div></li>
</ol></li>
</ol>
</div>

<div id="outline-container-org11daaa5" class="outline-4">
<h4 id="org11daaa5"><span class="section-number-4">2.2.1.</span> The Maybe Unused Attribute</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
If we don't want the compiler to complain about unused variables, we can define variables with <code>[[maybe_unused]]</code>.
This was introduced in C++17.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-type">float</span> <span class="org-variable-name">pi</span> <span class="org-rainbow-delimiters-depth-1">{</span>3.14<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd6b7b06" class="outline-3">
<h3 id="orgd6b7b06"><span class="section-number-3">2.3.</span> Implementation Defined Behavior</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Implementation-defined behavior means the behavior of some syntax is left up to the implementation (the compiler) to define. Such behaviors must be consistent and documented, but different compilers may produce different results.
One example of this is using the <code>sizeof</code> operator. It will product different results on different platforms.
</p>
</div>
</div>

<div id="outline-container-org07cccd7" class="outline-3">
<h3 id="org07cccd7"><span class="section-number-3">2.4.</span> Identifier Naming Conventions</h3>
<div class="outline-text-3" id="text-2-4">
<ol class="org-ol">
<li>Variable names should begin with lowercase characters.</li>
<li>Function names should begin with lowercase characters.</li>
<li>Identifier names starting with capital letters represent user defined types.</li>
<li><code>camelCase</code> or <code>snake_case</code> both are fine but stay consistent.</li>
<li>You may mix them like <code>snake_case</code> for variable names and <code>camelCase</code> for function names.</li>
<li>Do not start names with underscore <code>_</code> (bad practice but not impossible).</li>
</ol>
</div>
</div>

<div id="outline-container-orgb477874" class="outline-3">
<h3 id="orgb477874"><span class="section-number-3">2.5.</span> Literals and Operators</h3>
<div class="outline-text-3" id="text-2-5">
<p>
A literal is a constant value inserted directly in the source code.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">a</span> = 5;
<span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-constant">std</span>::endl;  <span class="org-comment-delimiter">// </span><span class="org-comment">a is a variable not a literal constant</span>
<span class="org-constant">std</span>::cout &lt;&lt; 10 &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">10 is a literal constant</span>
</pre>
</div>

<p>
Operators perform operations on its inputs and return an output.
The number of inputs an operator can take is called its <b>arity</b>.
Some operators like <code>throw</code> and <code>delete</code> do not return any value.
Operators which are mainly used for their side effects like <code>x = 5</code> always return their left operand (<code>x</code> in this case).
For example, <code>x = y = 5</code> is the same as writing <code>x = (y = 5)</code>.
</p>
</div>
</div>

<div id="outline-container-org2100fed" class="outline-3">
<h3 id="org2100fed"><span class="section-number-3">2.6.</span> Expressions</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Expressions are like phrases in English, they are part of statements just like phrases are part of sentences.
Expressions do not end with a semi-colon and they cannot be executed themselves.
Some examples of expressions-
</p>
<div class="org-src-container">
<pre class="src src-C++">a = 5              <span class="org-comment-delimiter">// </span><span class="org-comment">has a side-effect of assigning "a" to 5 and evaluates to "a"</span>
5 + 6              <span class="org-comment-delimiter">// </span><span class="org-comment">evaluates to 11</span>
<span class="org-string">"Hello, World!"</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">evaluates to itself</span>
<span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Hey"</span> <span class="org-comment-delimiter">// </span><span class="org-comment">evaluates to std::cout</span>
</pre>
</div>
<p>
Ending an expression with a semi-colon <code>;</code> will cause the statement to execute properly and such expressions are called <b>Expression Statements</b>.
Sub-expressions are expressions used as operands in other expressions.
Compound expressions have two or more operators like <code>x = 5 + 3</code> has two operators, <code>=</code> and <code>+</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-org93778f3" class="outline-2">
<h2 id="org93778f3"><span class="section-number-2">3.</span> Functions and Files</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org05a4004" class="outline-3">
<h3 id="org05a4004"><span class="section-number-3">3.1.</span> Return values</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The main function can return integers to specify if the program ran successfully or not.
Two macros, <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> are defined in the <code>cstdlib</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdlib</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> EXIT_SUCCESS;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<p>
A value defining function which does not return any value will produce undefined results.
</p>
</div>
</div>
<div id="outline-container-org679130c" class="outline-3">
<h3 id="org679130c"><span class="section-number-3">3.2.</span> Parameters and Arguments</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>Parameters are defined in the function header and arguments are passed when calling it.</li>
<li><p>
If you have a parameter that is no longer used in the body but can't remove the corresponding argument from all function calls, you can just remove the identifier-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-comment-delimiter">/*</span><span class="org-comment">name</span><span class="org-comment-delimiter">*/</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">indentifier removed from parameter list</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">to avoid breaking previous function calls</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">and prevent unused parameter warning</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<blockquote>
<p>

</p>

<p>
IMPORTANT!
Note that in clang, arguments are parsed from left to right while in g++, arguments are parsed from right to left!
</p>
</blockquote></li>
</ul>
</div>
</div>
<div id="outline-container-org3186f55" class="outline-3">
<h3 id="org3186f55"><span class="section-number-3">3.3.</span> The One Definition Rule</h3>
<div class="outline-text-3" id="text-3-3">
<ol class="org-ol">
<li>Within a file, each function, variable, type or template can only have one definition (except variables in different local scopes) (violation causes compile error)</li>
<li>With a program (multiple files), each variable can have only one definition (violation causes linker error)</li>
<li>Types, templates, inline functions, and inline variables are allowed to have duplicate definitions in different files, so long as each definition is identical (violation causes undefined behaviour).</li>
</ol>
</div>
</div>
<div id="outline-container-org032874e" class="outline-3">
<h3 id="org032874e"><span class="section-number-3">3.4.</span> Namespaces</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>A namespace provides a scope region called the namespace scope which means that any thing defined in that scope won't be mistaken for anything else with the same name defined in some other namespace.</li>
<li>Only declarations and definitions can appear in a namespace.</li>
<li>The <code>::</code> operator is called the <b>scope resolution operator</b>. It's left operand is the namespace name (if blank, global is used) and the right operator is the symbol.</li>
<li>When an identifier uses the <code>::</code> operator, it's called a qualified name.</li>
<li>Using <code>using namespace &lt;name&gt;</code> is considered bad practice since it can lead to many conflicts in the future.</li>
</ul>
</div>
</div>
<div id="outline-container-org9c7ae19" class="outline-3">
<h3 id="org9c7ae19"><span class="section-number-3">3.5.</span> Preprocessor</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>A preprocessor is a <i>program</i> which makes various changes to the code file before compiling it. For example, stripping out comments, making sure the each file ends with a newline character etc, evaluating the <b>preprocessor directives</b>, etc..</li>
<li>It does not make changes to the original files, instead it creates temporary files for this called "translation units".</li>
<li>The translation unit is what is actually compiled by the compiler.</li>
</ul>
</div>
<div id="outline-container-org4129e2b" class="outline-4">
<h4 id="org4129e2b"><span class="section-number-4">3.5.1.</span> Preprocessor Directives</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>These are statements that begin with a <code>#</code> and end with a newline.</li>
<li>They have their own syntax of doing things.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org70a3360"></a>Include Directive<br />
<div class="outline-text-5" id="text-3-5-1-1">
<p>
Includes header files - <code>#include &lt;iostream&gt;</code>
</p>
</div>
</li>
<li><a id="orga75b5ba"></a>Define Directive<br />
<div class="outline-text-5" id="text-3-5-1-2">
<ul class="org-ul">
<li>Used to define function macros or object macros.</li>
<li>Function macros are not considered unsafe.</li>
<li><p>
Object-like macros are no longer used in favour of better alternatives.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Replace all occurance of NOTHING with nothing</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">NOTHING</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Replace all occurances of PI with 3.14</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">PI</span> 3.14
</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="org16a8eea"></a>Conditional Directives<br />
<div class="outline-text-5" id="text-3-5-1-3">
<p>
This includes the <code>ifdef</code>, <code>ifndef</code> and <code>endif</code> directives.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgd941a90" class="outline-4">
<h4 id="orgd941a90"><span class="section-number-4">3.5.2.</span> Header Files</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>Header files must not contain definitions.</li>
<li>It is a good practice for code files to #include their paired header file (if one exists), this will help the compiler catch errors at compile time instead of link time.</li>
<li>Many useful C libraries are now renamed in C++, for example, <code>stdlib.h</code> is named <code>cstdlib</code> in C++.</li>
<li>The <i>bad</i> way to include header files is to use relative paths in the <code>#include</code> directive. For example, <code>#include "../myfile.h"</code>.</li>
<li>The better way is to specify the <code>include directory</code> to the compiler using the <code>-I</code> flag- <code>g++ main.cpp -I/src/includes -o main</code>. There is no space after <code>-I</code> in the command.</li>
</ul>
</div>
</div>
<div id="outline-container-org2e49f3e" class="outline-4">
<h4 id="org2e49f3e"><span class="section-number-4">3.5.3.</span> Header Guards</h4>
<div class="outline-text-4" id="text-3-5-3">
<p>
Used to prevent duplication definitions when including multiple header files.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> FUNCTIONS_H
<span class="org-preprocessor">#define</span> <span class="org-variable-name">FUNCIONS_H</span>
<span class="org-rainbow-delimiters-depth-1">{</span>...<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-preprocessor">#endif</span>
</pre>
</div>

<ul class="org-ul">
<li>You can also use <code>#pragma once</code> in modern compilers instead of the above header guards, but it's not in the C++ standard and some compilers may not support it.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org0950472" class="outline-2">
<h2 id="org0950472"><span class="section-number-2">4.</span> Debugging</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgecd61c4" class="outline-3">
<h3 id="orgecd61c4"><span class="section-number-3">4.1.</span> Some Debugging Tactics</h3>
<div class="outline-text-3" id="text-4-1">
<ol class="org-ol">
<li>Comment out code</li>
<li>Use <code>std::cerr</code> instead of <code>std::cout</code> because <code>std::cerr</code> is unbuffered so output is instant.</li>
<li>Printing values.</li>
</ol>
<p>
Using debug statements isn't recommended since they can clutter your code.
</p>
</div>
</div>
<div id="outline-container-orgdd0042a" class="outline-3">
<h3 id="orgdd0042a"><span class="section-number-3">4.2.</span> Using a debugger</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org617ba5d" class="outline-4">
<h4 id="org617ba5d"><span class="section-number-4">4.2.1.</span> Step Into</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Execute the next command and pause.
If the next command is a function call, move to the top of the function.
</p>
</div>
</div>
<div id="outline-container-orgc9277f1" class="outline-4">
<h4 id="orgc9277f1"><span class="section-number-4">4.2.2.</span> Step Over</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
Execute the next command and pause.
If the next command is a function call, execute the entire function at once.
</p>
</div>
</div>
<div id="outline-container-orgdeb7766" class="outline-4">
<h4 id="orgdeb7766"><span class="section-number-4">4.2.3.</span> Step Out</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
Execute all remaining lines in the current function and pause.
</p>
</div>
</div>
<div id="outline-container-org95b604c" class="outline-4">
<h4 id="org95b604c"><span class="section-number-4">4.2.4.</span> Run to Cursor</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
Execute the program upto the line the cursor is in and pause.
</p>
</div>
</div>
<div id="outline-container-orgc7d9693" class="outline-4">
<h4 id="orgc7d9693"><span class="section-number-4">4.2.5.</span> Continue</h4>
<div class="outline-text-4" id="text-4-2-5">
<p>
Continue running the program normally.
</p>
</div>
</div>
<div id="outline-container-orge76b543" class="outline-4">
<h4 id="orge76b543"><span class="section-number-4">4.2.6.</span> Breakpoints</h4>
<div class="outline-text-4" id="text-4-2-6">
<p>
Execute the program upto the breakpoint and pause.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org525cfb5" class="outline-2">
<h2 id="org525cfb5"><span class="section-number-2">5.</span> Data Types and Related Stuff</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org8429077" class="outline-3">
<h3 id="org8429077"><span class="section-number-3">5.1.</span> Standard Integers</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Since the size of <code>int</code> is different on different compilers on different platforms, standard int was declared in the <code>cstdint</code> library.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">int8_t</span> <span class="org-variable-name">one</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">1 byte integer</span>
  <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">two</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">1 byte unsigned integer</span>
  <span class="org-constant">std</span>::<span class="org-type">int16_t</span> <span class="org-variable-name">three</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">2 byte integer</span>
  <span class="org-constant">std</span>::<span class="org-type">uint16_t</span> <span class="org-variable-name">four</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">2 byte unsigned integer</span>
  <span class="org-constant">std</span>::<span class="org-type">int32_t</span> <span class="org-variable-name">five</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">4 byte integer</span>
  <span class="org-constant">std</span>::<span class="org-type">uint32_t</span> <span class="org-variable-name">six</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">4 byte unsigned integer</span>
  <span class="org-constant">std</span>::<span class="org-type">int64_t</span> <span class="org-variable-name">seven</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">8 byte integer</span>
  <span class="org-constant">std</span>::<span class="org-type">uint64_t</span> <span class="org-variable-name">eight</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">8 byte unsigned integer</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The above may be slower on some hardware. For example, 32 bit integers may be slower than 64 bit integers on a 64bit CPU so the following types were created:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">int_fast32_t</span> <span class="org-variable-name">a</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will give the fastest integer having atleast 32 bits</span>
  <span class="org-constant">std</span>::<span class="org-type">int_least32_t</span> <span class="org-variable-name">b</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will give the smallest integer having atleast 32 bits</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<blockquote>
<p>

</p>

<p>
Note that in many compilers, <code>int_fast8_t</code> and <code>int_least8_t</code> behave like <code>char</code> instead of integer values so prefer using the 16bit versions. So, if you try to print a variable of type <code>int_fast8_t</code> with the value 65 (for example), it will print A instead!!
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orge6cca15" class="outline-3">
<h3 id="orge6cca15"><span class="section-number-3">5.2.</span> <code>size_t</code></h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>This type is used to represent size or length of objects.</li>
<li>The data type of the value returned by the <code>sizeof</code> operator is also <code>std::size_t</code>.</li>
<li>It is guaranteed to be unsigned and has the size of the largest possible integer the machine can hold.</li>
<li>Any object with a size larger than the largest value an object of type <code>std::size_t</code> can hold is considered ill-formed.</li>
</ul>
</div>
</div>
<div id="outline-container-orga4a0aa6" class="outline-3">
<h3 id="orga4a0aa6"><span class="section-number-3">5.3.</span> Floating Point Precision</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>By default, <code>std::cout</code> displays only upto 6 significant digits of floating point numbers. You can change the precision by using <code>std::cout &lt;&lt; std::setprecision(&lt;any number&gt;)</code>.</li>
<li>Prefer <code>double</code> over <code>float</code> for better precision.</li>
</ul>
</div>
</div>
<div id="outline-container-orge3785df" class="outline-3">
<h3 id="orge3785df"><span class="section-number-3">5.4.</span> Rounding Errors in Decimals</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li><p>
In binary, a simple decimal number like 0.1 is represented in an infinite sequence 0.00011001100&#x2026; causing it to be less precise.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">double</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">{</span>0.1<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>20<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  b = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1; <span class="org-comment-delimiter">// </span><span class="org-comment">should be equal to 1.0</span>
  <span class="org-constant">std</span>::cout &lt;&lt; b &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>a == b<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"YES"</span>;
  <span class="org-keyword">else</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"NO"</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgeef7771" class="outline-3">
<h3 id="orgeef7771"><span class="section-number-3">5.5.</span> NaN and Infinity</h3>
<div class="outline-text-3" id="text-5-5">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">double</span> <span class="org-variable-name">zero</span> <span class="org-rainbow-delimiters-depth-2">{</span>0.0<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; 5.0/zero &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">outputs inf</span>
  <span class="org-constant">std</span>::cout &lt;&lt; zero/zero &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">outputs nan</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb0dc99e" class="outline-3">
<h3 id="orgb0dc99e"><span class="section-number-3">5.6.</span> Boolean Values</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>No need to import <code>stdbool</code> like in C to use <code>true</code> and <code>false</code>.</li>
<li>Sending <code>true</code> and <code>false</code> values to stdout prints 0 and 1 instead.</li>
<li><p>
To print true and false instead, do this-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">bool</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">b</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-negation-char">!</span>a<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-string">" "</span> &lt;&lt; b &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha; <span class="org-comment-delimiter">// </span><span class="org-comment">causes bools to print as "true" or "false"</span>
  <span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-string">" "</span> &lt;&lt; b &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org63aa26e" class="outline-3">
<h3 id="org63aa26e"><span class="section-number-3">5.7.</span> Explicit Type Conversions</h3>
<div class="outline-text-3" id="text-5-7">
<ul class="org-ul">
<li><p>
Unlike C, where we convert types using <code>(&lt;type&gt;) variable</code> to cast to different types, in C++, we use <code>static_cast</code> operator.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">{</span>5<span class="org-rainbow-delimiters-depth-2">}</span>;
  print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>a<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>
  
The <code>static_cast</code> operator will produce undefined behavior if the value being converted doesn’t fit in range of the new type.
</p>
</blockquote></li>
</ul>
</div>
</div>
<div id="outline-container-orgb365da9" class="outline-3">
<h3 id="orgb365da9"><span class="section-number-3">5.8.</span> Hexadecimal, Octal and Binary Literals</h3>
<div class="outline-text-3" id="text-5-8">
<p>
You may use these decimals by prefixing the following-
</p>
<ul class="org-ul">
<li><code>0x</code> for hexadecimal, eg- <code>int a{0x1F}</code></li>
<li><code>0</code> for octal, eg- <code>int a{012}</code></li>
<li><code>0b</code> for binary, eg- <code>int a{0b1100011}</code> (c++14 onwards)</li>
</ul>
<p>
By default, <code>std::cout</code> outputs values in decimals.
You can specify the output type using-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">bitset</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">for std::bitset</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">{</span>69420<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Decimal</span>
  <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Octal</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::oct;
  <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Hexadecimal</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::hex;
  <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Binary</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::<span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>16<span class="org-rainbow-delimiters-depth-2">&gt;{</span>0b10110<span class="org-rainbow-delimiters-depth-2">}</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
In C++20 and C++23, better options are available-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">format</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">C++20</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">#include &lt;print&gt; // C++23</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::format<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"{:b}\n"</span>, 0b1100101<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::format<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"{:#b}\n"</span>, 0b1100101<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">std::print("{:#b}\n", 0b1100101); C++23</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0b5c3fe" class="outline-2">
<h2 id="org0b5c3fe"><span class="section-number-2">6.</span> Constants and Strings</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgb769f53" class="outline-3">
<h3 id="orgb769f53"><span class="section-number-3">6.1.</span> Constant Expressions</h3>
<div class="outline-text-3" id="text-6-1">
<p>
An expression that contains only compile time constants.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">a</span> = <span class="org-rainbow-delimiters-depth-1">{</span> 5 + 7 <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Will be evaluated at compile-time</span>
<span class="org-type">int</span> <span class="org-variable-name">a</span> = <span class="org-rainbow-delimiters-depth-1">{</span> 5 + 7 <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Might be evaluated at runtime, depends on the compiler</span>
</pre>
</div>

<p>
Using <code>const</code> can let the compiler know that the variable will absolutely <i>not</i> change whatsoever, so it can optimize it!
</p>

<blockquote>
<p>

</p>

<p>
Only const <i>integral</i> variables with a constant expression initializer are compile-time constants.
So, doubles or floats do not count.
Types like char, bool, int, long, unsigned long etc can be considered.
</p>
</blockquote>

<ul class="org-ul">
<li>It is sometimes very hard to distinguish whether an expression evaluates to a compile-time constant or not, so we can use <code>constexpr</code> keyword to tell the compiler that it's a compile time constant (using <code>const</code> doesn't guarantee it because it just means that the variable's value cannot be changed).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-1">{</span> 5 + 7 <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Will be evaluated at compile-time instead of run-time</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf059c20" class="outline-3">
<h3 id="orgf059c20"><span class="section-number-3">6.2.</span> The Inline Keyword</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>Every function call has a cost. Whenever a function call is made, the CPU has to save the current state of the program, jump to the function, execute it, and then jump back to the original location and restore the state. This is called function call overhead.</li>
<li>Inline functions are functions whose definition is expanded in-place instead of being called. This reduces the function call overhead.</li>
<li>The <code>inline</code> keyword just suggests the compiler to make the function inline, it is not guaranteed to do so.</li>
<li>Inline functions perform better when they are small and are called frequently.</li>
<li>Inline functions are <b>allowed</b> to be defined in multiple translation units in modern C++!</li>
<li>Every inline definition must be identical and are mostly defined in header files.</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-function-name">is_even</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> x % 2 == 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org11a99a4" class="outline-3">
<h3 id="org11a99a4"><span class="section-number-3">6.3.</span> <code>constexpr</code> and <code>consteval</code></h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>As stated above, <code>constexpr</code> is used to tell the compiler that a variable is a compile-time constant.</li>
<li><p>
<code>constexpr</code> can be used with functions to tell the compiler that the function is a compile-time function.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-function-name">greater</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>x &gt; y ? x : y<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>If the parameters passed to a <code>constexpr</code> function are not compile-time constants, the function will be evaluated at run-time.</li>
<li>If the return value is not being used in a context where a compile-time constant is required, the function may or may not be evaluated at run-time.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">for std::is_constant_evaluated</span>

<span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-function-name">greater</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>x &gt; y ? x : y<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">p</span> <span class="org-rainbow-delimiters-depth-2">{</span>greater<span class="org-rainbow-delimiters-depth-3">(</span>5, 6<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">always a compile time constant</span>
  <span class="org-constant">std</span>::cout &lt;&lt; p &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-constant">std</span>::cout &lt;&lt; greater<span class="org-rainbow-delimiters-depth-2">(</span>5, 6<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">may be a compile time constant</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcf292cd" class="outline-3">
<h3 id="orgcf292cd"><span class="section-number-3">6.4.</span> Immediate Functions</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>We can force functions which <i>will</i> be used in a context where a compile-time constant is required to be evaluated at compile-time using the <code>consteval</code> keyword.</li>
<li>Only available in C++20.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">consteval</span> <span class="org-type">bool</span> <span class="org-function-name">getbigger</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>a &gt; b ? a : b<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">{</span>getbigger<span class="org-rainbow-delimiters-depth-3">(</span>5, 6<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">ok</span>

  <span class="org-constant">std</span>::cout &lt;&lt; getbigger<span class="org-rainbow-delimiters-depth-2">(</span>5, 6<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">ok</span>

  <span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-2">{</span>5<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">not constexpr</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getbigger<span class="org-rainbow-delimiters-depth-2">(</span>x, 6<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">error</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>These functions are compile-time functions so they aren't very flexible during run-time.</li>
<li><code>consteval</code> and <code>constexpr</code> functions are implicitly <code>inline</code> because the compiler needs to see the full definition at all times where the function is called.</li>
</ul>
</div>
</div>
<div id="outline-container-org1ec837b" class="outline-3">
<h3 id="org1ec837b"><span class="section-number-3">6.5.</span> Strings</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>C like strings are avoided because they are hard to work with and can be unsafe.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Prayag"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  name = <span class="org-string">"Prayag Jain"</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">can be reassigned</span>
  <span class="org-constant">std</span>::cout &lt;&lt; name &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>You can use <code>std::getline()</code> to read strings in C++.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">str</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Enter name: "</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">std::cin &gt;&gt; std::ws is an expression which ultimately returns std::cin</span>
  <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin &gt;&gt; <span class="org-constant">std</span>::ws, str<span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Hi there, "</span> &lt;&lt; str &lt;&lt; <span class="org-string">"!"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li><code>std::ws</code> is an input manipulator which allows getline to ignore any leading whitespace characters already present in the input buffer.</li>
<li><code>std::ws</code> is not preserved across calls so it must be used with every getline call.</li>
<li>Use <code>str.length()</code> or <code>std::ssize(str)</code> (defined in <code>&lt;string&gt;</code>) to get the length of a string named <code>str</code>.</li>
<li>Initializing using <code>std::string</code> is expensive, so do not pass them by value in functions.</li>
<li>Normal string literals with double quotes around them are C-Style string literals, E.g. <code>"hello"</code>.</li>
<li>Using the suffix <code>std::string_literals::s</code> will form an <code>std::string</code> literal, E.g. <code>"hello"std::string_literals::s</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-org7b1aba7" class="outline-3">
<h3 id="org7b1aba7"><span class="section-number-3">6.6.</span> <code>std::string_view</code></h3>
<div class="outline-text-3" id="text-6-6">
<ul class="org-ul">
<li>Whenever an <code>std:string</code> is initialized, the string literal provided is copied into the string object (expensive operation).</li>
<li>Even in functions, when an <code>std::string</code> is passed by value, it is copied into the function parameter (expensive operation).</li>
<li><code>std::string_view</code> is a lightweight alternative to <code>std::string</code>.</li>
<li>Always prefer <code>std::string_view</code> over <code>std::string</code> unless you need to modify the string.</li>
<li>It lives under the <code>&lt;string_view&gt;</code> header.</li>
<li>Assigning a new string to a <code>std::string_view</code> will not change the original string, it will just point to the new string.</li>
<li>You can use the <code>std::string_view_literals::sv</code> suffix to form a <code>std::string_view</code> literal.</li>
<li>Unlike <code>std::string</code>, <code>std::string_view</code> can be used in <code>constexpr</code> contexts.</li>
<li>The <code>remove_prefix(count)</code> and <code>remove_suffix(count)</code> member functions can be used to remove a prefix or suffix from a string view (does NOT modify the referenced string, just the view).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string_view</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">str</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Hello, World!"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; str &lt;&lt; <span class="org-constant">std</span>::endl;;

  str.remove_prefix<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">remove the first two characters</span>
  str.remove_suffix<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">remove the last two characters</span>
  <span class="org-constant">std</span>::cout &lt;&lt; str &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org10c356e" class="outline-2">
<h2 id="org10c356e"><span class="section-number-2">7.</span> Operators</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgbd237c0" class="outline-3">
<h3 id="orgbd237c0"><span class="section-number-3">7.1.</span> Binary Division Operator</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>It's the <code>/</code> operator we use to divide its two operands.</li>
<li>If one of the operands is a float, the operator performs floating point division.</li>
<li>If both operands are integers, the operator performs integer division and removes the fractional part.</li>
<li>If we want to divide two integers and get a float, we can use the <code>static_cast&lt;type&gt;</code> operator to cast one of the operands to a float/double.</li>
</ul>
</div>
</div>
<div id="outline-container-orgf9b9d12" class="outline-3">
<h3 id="orgf9b9d12"><span class="section-number-3">7.2.</span> Comma Operator</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li><code>x,y</code> means first evaluate x, then evaluate y and finally return the value of y</li>
</ul>
</div>
</div>
<div id="outline-container-org291ed14" class="outline-3">
<h3 id="org291ed14"><span class="section-number-3">7.3.</span> Comparing floating points</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>Floating points are dangerous to compare using the traditional comparison operators like <code>==</code>, <code>&lt;</code> and <code>&gt;</code> because of rounding errors.</li>
<li>Use the nearly equal algorithm which makes use of relative epsilons to check if two floating points are nearly equal.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org913e616" class="outline-2">
<h2 id="org913e616"><span class="section-number-2">8.</span> Bit Manipulation</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>We can use individual bits in a byte to store boolean values or values that only depend on one bit.</li>
<li>When individual bits of an object are used as boolean values, we call them <b>bit flags</b>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">bitset</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>8<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">mybitset</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>We reading bits, we number them from right to left (starting from 0).</li>
</ul>
</div>
<div id="outline-container-org1dc0b6e" class="outline-3">
<h3 id="org1dc0b6e"><span class="section-number-3">8.1.</span> Key Member Functions</h3>
<div class="outline-text-3" id="text-8-1">
</div>
<div id="outline-container-org97984c3" class="outline-4">
<h4 id="org97984c3"><span class="section-number-4">8.1.1.</span> <code>test(position)</code></h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
Used to test whether a bit is 0 or 1
</p>
</div>
</div>
<div id="outline-container-org920d011" class="outline-4">
<h4 id="org920d011"><span class="section-number-4">8.1.2.</span> <code>set(position)</code></h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
Used to turn a bit "on" (to 1).
</p>
</div>
</div>
<div id="outline-container-org434dfa4" class="outline-4">
<h4 id="org434dfa4"><span class="section-number-4">8.1.3.</span> <code>reset(position)</code></h4>
<div class="outline-text-4" id="text-8-1-3">
<p>
Used to turn a bit "off" (to 0).
</p>
</div>
</div>
<div id="outline-container-org54c07e0" class="outline-4">
<h4 id="org54c07e0"><span class="section-number-4">8.1.4.</span> <code>flip(position)</code></h4>
<div class="outline-text-4" id="text-8-1-4">
<p>
Used to flip a bit (to 1 if it was 0 and to 0 if it was 1).
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">bitset</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>5<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">bits</span><span class="org-rainbow-delimiters-depth-2">{</span>0b10101<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; bits &lt;&lt; <span class="org-string">'\n'</span>;

  bits.set<span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; bits &lt;&lt; <span class="org-string">'\n'</span>;

  bits.flip<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; bits &lt;&lt; <span class="org-string">'\n'</span>;

  bits.reset<span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; bits &lt;&lt; <span class="org-string">'\n'</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org490b122" class="outline-4">
<h4 id="org490b122"><span class="section-number-4">8.1.5.</span> <code>size()</code></h4>
<div class="outline-text-4" id="text-8-1-5">
<p>
Returns the number of bits in the bitset.
</p>
</div>
</div>
<div id="outline-container-org041d359" class="outline-4">
<h4 id="org041d359"><span class="section-number-4">8.1.6.</span> <code>count()</code></h4>
<div class="outline-text-4" id="text-8-1-6">
<p>
Returns the number of bits set to 1.
</p>
</div>
</div>
<div id="outline-container-orgbf12839" class="outline-4">
<h4 id="orgbf12839"><span class="section-number-4">8.1.7.</span> <code>any()</code></h4>
<div class="outline-text-4" id="text-8-1-7">
<p>
Returns true if any bit is set to 1.
</p>
</div>
</div>
<div id="outline-container-org225c141" class="outline-4">
<h4 id="org225c141"><span class="section-number-4">8.1.8.</span> <code>none()</code></h4>
<div class="outline-text-4" id="text-8-1-8">
<p>
Returns true if none of the bits are set to 1.
</p>
</div>
</div>
<div id="outline-container-org1f48879" class="outline-4">
<h4 id="org1f48879"><span class="section-number-4">8.1.9.</span> <code>all()</code></h4>
<div class="outline-text-4" id="text-8-1-9">
<p>
Returns true if all of the bits are set to 1.
</p>
</div>
</div>
</div>
<div id="outline-container-org3a418ff" class="outline-3">
<h3 id="org3a418ff"><span class="section-number-3">8.2.</span> Bitwise Operators</h3>
<div class="outline-text-3" id="text-8-2">
<ol class="org-ol">
<li><code>&gt;&gt;</code> (right shift) (eg- 0011 &gt;&gt; 1 = 0001, 0011 &gt;&gt; 2 = 0000)</li>
<li><code>&lt;&lt;</code> (left shift) (eg- 0011 &lt;&lt; 1 = 0110, 0011 &lt;&lt; 2 = 1100)</li>
<li><code>&amp;</code> (bitwise and) (eg- 0101 &amp; 0011 = 0001)</li>
<li><code>|</code> (bitwise or) (eg- 0101 | 0011 = 0111) (only one bit should be 1 to be evaluated as true)</li>
<li><code>^</code> (bitwise xor) (eg- 0101 ^ 0011 = 0110)</li>
<li><code>~</code> (bitwise not) (eg- ~0101 = 1010)</li>
</ol>
</div>
</div>
<div id="outline-container-org0063ca8" class="outline-3">
<h3 id="org0063ca8"><span class="section-number-3">8.3.</span> Bit Masks</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>Used to block bitwise operators from modifying bits we don't want in a bitset, much like we use masking tape to block paint from touching certain parts of the product we're painting.</li>
<li>We can define bit masks as normal integers using either binary literals (c++14 or above) or by converting binary numbers to other literals such as decimals or hexadecimals.</li>
</ul>
</div>
<div id="outline-container-orgc7c8d11" class="outline-4">
<h4 id="orgc7c8d11"><span class="section-number-4">8.3.1.</span> Testing Bits using Masks</h4>
<div class="outline-text-4" id="text-8-3-1">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">creating masks</span>
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask1</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00000001<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask2</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00000010<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask3</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00000100<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask4</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00001000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask5</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00010000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask6</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00100000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask7</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b01000000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask8</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b10000000<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">testing if a bit at position 4 (starting from 0 from the right) is on or off using masks</span>
  <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">flags</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b01111011<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">arbitrary value</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"4th bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask5</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf5934d3" class="outline-4">
<h4 id="orgf5934d3"><span class="section-number-4">8.3.2.</span> Setting and Resetting Bits using Masks</h4>
<div class="outline-text-4" id="text-8-3-2">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">creating masks</span>
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask1</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00000001<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask2</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00000010<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask3</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00000100<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask4</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00001000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask5</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00010000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask6</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b00100000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask7</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b01000000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>maybe_unused<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">mask8</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b10000000<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-constant">std</span>::<span class="org-type">uint8_t</span> <span class="org-variable-name">flags</span> <span class="org-rainbow-delimiters-depth-2">{</span>0b01101101<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">turning flag 4 on</span>
  flags |= mask5; <span class="org-comment-delimiter">// </span><span class="org-comment">using bitwise OR</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">turning flag 0 off</span>
  flags &amp;= ~mask1; <span class="org-comment-delimiter">// </span><span class="org-comment">using bitwise AND and bitwise NOT</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">flipping bit 7</span>
  flags ^= mask8; <span class="org-comment-delimiter">// </span><span class="org-comment">using bitwise XOR</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">flipping bits 3 and 2 simultaneously</span>
  flags ^= <span class="org-rainbow-delimiters-depth-2">(</span>mask4 | mask3<span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 4th bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask5</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 0th bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask1</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 7th bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask8</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 3rd bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask4</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 2rd bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask3</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>You may use <code>std::bitset</code> instead of <code>std::uint8_t</code> too!</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5904666" class="outline-3">
<h3 id="org5904666"><span class="section-number-3">8.4.</span> Example Hex Colour to RGBA Colour</h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">
<pre class="src src-bash">printf <span class="org-string">"FF03CA04"</span> &gt; /tmp/inp
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">bitset</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">defining masks</span>
  <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint32_t</span> <span class="org-variable-name">redBits</span> <span class="org-rainbow-delimiters-depth-2">{</span>0xFF000000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint32_t</span> <span class="org-variable-name">blueBits</span> <span class="org-rainbow-delimiters-depth-2">{</span>0x00FF0000<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint32_t</span> <span class="org-variable-name">greenBits</span> <span class="org-rainbow-delimiters-depth-2">{</span>0x0000FF00<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">uint32_t</span> <span class="org-variable-name">alphaBits</span> <span class="org-rainbow-delimiters-depth-2">{</span>0x000000FF<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-constant">std</span>::<span class="org-type">uint32_t</span> <span class="org-variable-name">hexVal</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-constant">std</span>::cin &gt;&gt; <span class="org-constant">std</span>::hex &gt;&gt; hexVal; <span class="org-comment-delimiter">// </span><span class="org-comment">std::hex allows us to read in hex (input modifier)</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">getting individual colours as integers</span>
  <span class="org-type">int</span> <span class="org-variable-name">red</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">hexVal</span> &amp; <span class="org-variable-name">redBits</span><span class="org-rainbow-delimiters-depth-4">)</span> &gt;&gt; 24<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">blue</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">hexVal</span> &amp; <span class="org-variable-name">blueBits</span><span class="org-rainbow-delimiters-depth-4">)</span> &gt;&gt; 16<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">green</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">hexVal</span> &amp; <span class="org-variable-name">greenBits</span><span class="org-rainbow-delimiters-depth-4">)</span> &gt;&gt; 8<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">alpha</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">hexVal</span> &amp; <span class="org-variable-name">alphaBits</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"rgba("</span> &lt;&lt; red &lt;&lt; <span class="org-string">","</span> &lt;&lt; blue &lt;&lt; <span class="org-string">","</span> &lt;&lt; green &lt;&lt; <span class="org-string">","</span> &lt;&lt; alpha &lt;&lt; <span class="org-string">")"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org037ac6c" class="outline-3">
<h3 id="org037ac6c"><span class="section-number-3">8.5.</span> Two's Complement</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li>Signed integers are typically stored in two's complement format.</li>
<li>In two's complement, the most significant bit (left most bit) is used to represent the sign of the number.</li>
<li>0 means positive and 1 means negative.</li>
<li>To convert a decimal number to a negative binary number, we invert all the bits and add 1.</li>
<li>Example, to convert -5 to binary, we first convert 5 to binary (0101) and then invert all the bits (1010) and add 1 (1011).</li>
<li>We add 1 because we need to represent 0 as 0000 and not 1111.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org815ee1e" class="outline-2">
<h2 id="org815ee1e"><span class="section-number-2">9.</span> Namespaces</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>A namespace provides a scope region called the namespace scope which means that any thing defined in that scope won't be mistaken for anything else with the same name defined in some other namespace.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; y &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">namespace</span> <span class="org-constant">mynamespace</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span>5<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">defining an arbitrary function in this namespace</span>
  <span class="org-type">void</span> <span class="org-function-name">doSomething</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    ::print<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"hello "</span>, b<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">use print from the global namespace instead of this namespace</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">mynamespace</span>::doSomething<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">mynamespace</span>::a<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">mynamespace</span>;
  doSomething<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<blockquote>
<p>

</p>

<p>
Multiple definitions of the same namespace is allowed in C++.
</p>
</blockquote>
<ul class="org-ul">
<li>Nested namespaces can be accessed by doing something like <code>namespaceOne::namespaceTwo::hello</code>.</li>
</ul>
</div>
<div id="outline-container-org7322e4f" class="outline-3">
<h3 id="org7322e4f"><span class="section-number-3">9.1.</span> Namespace Aliases</h3>
<div class="outline-text-3" id="text-9-1">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">namespace</span> <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">namespace</span> <span class="org-constant">Goo</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-3">{</span>5<span class="org-rainbow-delimiters-depth-3">}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">namespace</span> <span class="org-constant">fg</span> = <span class="org-constant">Foo</span>::Goo;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">fg</span>::a &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Avoid deeply nested namespaces!
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orga849d93" class="outline-2">
<h2 id="orga849d93"><span class="section-number-2">10.</span> Scope, Duration and Lifetime</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>Scope is the region of code where an identifier is visible (global, local, namespace, block).</li>
<li>Duration specifies the start and end of the lifetime of an object (auto, static).</li>
<li>Lifetime is the time for which an object exists in memory.</li>
<li>Global variables have static duration by default.</li>
<li>Non constant integral global variables are initialized to 0 by default.</li>
</ul>
</div>
<div id="outline-container-orgae3155f" class="outline-3">
<h3 id="orgae3155f"><span class="section-number-3">10.1.</span> Name Hiding (Shadowing)</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>Whenever a name is defined in a scope, it hides any other name with the same name in the outer scope.</li>
<li>You should generally <i>avoid</i> variable shadowing.</li>
<li>In g++, you can use the <code>-Wshadow</code> flag to get warnings about shadowing.</li>
</ul>
</div>
</div>
<div id="outline-container-org8e21aff" class="outline-3">
<h3 id="org8e21aff"><span class="section-number-3">10.2.</span> Internal Linkage</h3>
<div class="outline-text-3" id="text-10-2">
<ul class="org-ul">
<li>Linkage is the property of an identifier which specifies whether it can be used in other translation units.</li>
<li>There are three types of linkages-
<ol class="org-ol">
<li>External Linkage</li>
<li>Internal Linkage</li>
<li>No Linkage</li>
</ol></li>
<li>Local variables have no linkage.</li>
<li>Non constant global variables have external linkage by default while constant global variables have internal linkage by default.</li>
<li>To make global variables have internal linkage, use the <code>static</code> keyword.</li>
<li>Functions have external linkage by default but can also be made to have internal linkage using the <code>static</code> keyword.</li>
</ul>
<blockquote>
<p>

</p>

<p>
It is recommended to give internal linkage to all global variables and functions that are not used in other translation units.
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Internal global variables definitions:</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">g_x</span>;          <span class="org-comment-delimiter">// </span><span class="org-comment">defines non-initialized internal global variable (zero initialized by default)</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">g_x</span><span class="org-rainbow-delimiters-depth-1">{</span> 1 <span class="org-rainbow-delimiters-depth-1">}</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized internal global variable</span>

<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span> <span class="org-rainbow-delimiters-depth-1">{</span> 2 <span class="org-rainbow-delimiters-depth-1">}</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized internal global const variable</span>
<span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span> <span class="org-rainbow-delimiters-depth-1">{</span> 3 <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized internal global constexpr variable</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Internal function definitions:</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{}</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">defines internal function</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org6362e65" class="outline-3">
<h3 id="org6362e65"><span class="section-number-3">10.3.</span> External Linkage</h3>
<div class="outline-text-3" id="text-10-3">
<ul class="org-ul">
<li>To make a variable or function have external linkage, use the <code>extern</code> keyword.</li>
<li>Global variables and functions have external linkage by default so you don't need to use the <code>extern</code> keyword.</li>
</ul>
<blockquote>
<p>

</p>

<p>
If you want to define an uninitialized non-const global variable, do not use the extern keyword, otherwise C++ will think you’re trying to make a forward declaration for the variable
</p>
</blockquote>
<ul class="org-ul">
<li><code>constexpr</code> can be made to have external linkage by using the <code>extern</code> keyword however they can not be <i>forward declared</i>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">External global variable definitions:</span>
<span class="org-type">int</span> <span class="org-variable-name">g_x</span>;                       <span class="org-comment-delimiter">// </span><span class="org-comment">defines non-initialized external global variable (zero initialized by default)</span>
<span class="org-keyword">extern</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">g_x</span><span class="org-rainbow-delimiters-depth-1">{</span> 1 <span class="org-rainbow-delimiters-depth-1">}</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized const external global variable</span>
<span class="org-keyword">extern</span> <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">g_x</span><span class="org-rainbow-delimiters-depth-1">{</span> 2 <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized constexpr external global variable</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Forward declarations</span>
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span>;                <span class="org-comment-delimiter">// </span><span class="org-comment">forward declaration for non-constant global variable</span>
<span class="org-keyword">extern</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span>;          <span class="org-comment-delimiter">// </span><span class="org-comment">forward declaration for const global variable</span>
<span class="org-keyword">extern</span> <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">not allowed: constexpr variables can't be forward declared</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd17f1a8" class="outline-3">
<h3 id="orgd17f1a8"><span class="section-number-3">10.4.</span> Non-constant Global Variables are Evil</h3>
<div class="outline-text-3" id="text-10-4">
<ul class="org-ul">
<li>They can be changed from anywhere in the program.</li>
</ul>
<blockquote>
<p>

</p>

<p>
Dynamic initialization of global variables causes a lot of problems in C++. Avoid dynamic initialization whenever possible.
</p>
</blockquote>
<ul class="org-ul">
<li>Prefer using namespaces to avoid name collisions.</li>
<li>In functions, prefer passing variables as parameters instead of using global variables.</li>
</ul>
</div>
</div>
<div id="outline-container-orge798684" class="outline-3">
<h3 id="orge798684"><span class="section-number-3">10.5.</span> Sharing Global Variables Across Files</h3>
<div class="outline-text-3" id="text-10-5">
<ul class="org-ul">
<li>You can create header files, define a namespace, define the constants as <code>constexpr</code> and then include the header file in all files where you want to use the constants.</li>
<li>This approach has some downsides-
<ol class="org-ol">
<li>If the header file is used in 20 files, the definitions will be duplicated 20 times and each file will have to be recompiled if the header file is changed.</li>
<li>If the constants are large, it will increase memory usage because of duplication!</li>
</ol></li>
<li>Another approach is to define a namespace in a <code>.cpp</code> file, define the constants using <code>extern const</code> in the namespace, forward declare the constants in a <code>.h</code> header file and then include the header file in all files where you want to use the constants.</li>
<li>This approach also has some downsides-
<ol class="org-ol">
<li>These constants will now be considered compile-time only in the <code>.cpp</code> file in which they are defined because the linker will only see the forward declaration from the header file.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org6f13169" class="outline-3">
<h3 id="org6f13169"><span class="section-number-3">10.6.</span> Global Constants as Inline Variables</h3>
<div class="outline-text-3" id="text-10-6">
<ul class="org-ul">
<li>For C++17 and above, you can use inline variables to define global constants.</li>
<li>These variables are better than macros because they are type safe and can be debugged.</li>
<li>They are better than global constants because they are not duplicated across files.</li>
<li><p>
Prefer using them over the above two methods of sharing global variables across files.
</p>

<p>
<code>constants.h</code>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#IFNDEF</span> CONSTANTS_H
<span class="org-preprocessor">#DEFINE</span> CONSTANTS_H
<span class="org-keyword">namespace</span> <span class="org-constant">constants</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">pi</span> <span class="org-rainbow-delimiters-depth-2">{</span>3.14159<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-preprocessor">#ENDIF</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org775fb13" class="outline-3">
<h3 id="org775fb13"><span class="section-number-3">10.7.</span> Static on local variables</h3>
<div class="outline-text-3" id="text-10-7">
<ul class="org-ul">
<li>Using the static keyword on local variables changes its duration to be created at the start of the program and destroyed at the end.</li>
<li>It is common to use the <code>s_</code> prefix on static variable identifiers.</li>
<li>You should avoid static local variables unless the variable never needs to be reset as this can cause confusion.</li>
</ul>
</div>
</div>
<div id="outline-container-org5a9ce1b" class="outline-3">
<h3 id="org5a9ce1b"><span class="section-number-3">10.8.</span> Summary</h3>
<div class="outline-text-3" id="text-10-8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Type</td>
<td class="org-left">Example</td>
<td class="org-left">Scope</td>
<td class="org-left">Duration</td>
<td class="org-left">Linkage</td>
<td class="org-left">Notes</td>
</tr>

<tr>
<td class="org-left">Local variable</td>
<td class="org-left"><code>int x;</code></td>
<td class="org-left">Block</td>
<td class="org-left">Automatic</td>
<td class="org-left">None</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Static local variable</td>
<td class="org-left"><code>static int s_x;</code></td>
<td class="org-left">Block</td>
<td class="org-left">Static</td>
<td class="org-left">None</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Dynamic local variable</td>
<td class="org-left"><code>int* x { new int{} };</code></td>
<td class="org-left">Block</td>
<td class="org-left">Dynamic</td>
<td class="org-left">None</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Function parameter</td>
<td class="org-left"><code>void foo(int x)</code></td>
<td class="org-left">Block</td>
<td class="org-left">Automatic</td>
<td class="org-left">None</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">External non-constant global variable</td>
<td class="org-left"><code>int g_x;</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">External</td>
<td class="org-left">Initialized or uninitialized</td>
</tr>

<tr>
<td class="org-left">Internal non-constant global variable</td>
<td class="org-left"><code>static int g_x;</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">Internal</td>
<td class="org-left">Initialized or uninitialized</td>
</tr>

<tr>
<td class="org-left">Internal constant global variable</td>
<td class="org-left"><code>constexpr int g_x { 1 };</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">Internal</td>
<td class="org-left">Must be initialized</td>
</tr>

<tr>
<td class="org-left">External constant global variable</td>
<td class="org-left"><code>extern const int g_x { 1 };</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">External</td>
<td class="org-left">Must be initialized</td>
</tr>

<tr>
<td class="org-left">Inline constant global variable (C++17)</td>
<td class="org-left"><code>inline constexpr int g_x { 1 };</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">External</td>
<td class="org-left">Must be initialized</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgab75ff8" class="outline-2">
<h2 id="orgab75ff8"><span class="section-number-2">11.</span> Using Declarations</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-orgc95ed5d" class="outline-3">
<h3 id="orgc95ed5d"><span class="section-number-3">11.1.</span> Qualified and unqualified names</h3>
<div class="outline-text-3" id="text-11-1">
<p>
A qualified name is one which has been resolved using the namespace operator (<code>::</code>) or the member selection operators (<code>.</code>, <code>-&gt;</code>).
For example, <code>std::cout</code>, <code>std::pow(5, 3)</code>, <code>student.name</code> etc..
</p>
</div>
</div>
<div id="outline-container-orgcf0c139" class="outline-3">
<h3 id="orgcf0c139"><span class="section-number-3">11.2.</span> Using-declarations</h3>
<div class="outline-text-3" id="text-11-2">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-constant">cout</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">specifying the exact object that we'd like to use</span>
  cout &lt;&lt; <span class="org-string">"Hello World\n"</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org40e5df7" class="outline-3">
<h3 id="org40e5df7"><span class="section-number-3">11.3.</span> Using-directives</h3>
<div class="outline-text-3" id="text-11-3">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">importing the entire namespace into the current scope</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Prefer explicit namespaces over using-statements. Avoid using-directives whenever possible. Using-declarations are okay to use inside blocks.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgf934a29" class="outline-2">
<h2 id="orgf934a29"><span class="section-number-2">12.</span> Control Flow</h2>
<div class="outline-text-2" id="text-12">
<ul class="org-ul">
<li>The specific sequence of statements that the CPU executes is called the program's <b>execution path</b>.</li>
</ul>
</div>
<div id="outline-container-org9f90c65" class="outline-3">
<h3 id="org9f90c65"><span class="section-number-3">12.1.</span> Null Statements</h3>
<div class="outline-text-3" id="text-12-1">
<ul class="org-ul">
<li>Statements that just contain the semicolon <code>;</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span>
    ;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5626bf7" class="outline-3">
<h3 id="org5626bf7"><span class="section-number-3">12.2.</span> <code>constexpr</code> if statements</h3>
<div class="outline-text-3" id="text-12-2">
<ul class="org-ul">
<li><p>
Consider the following code-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">pi</span> <span class="org-rainbow-delimiters-depth-2">{</span>3.14<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>pi == 3.14<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Hello World"</span><span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Goodbye World"</span><span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">This will never be printed</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>The condition above is <i>always</i> true.</li>
<li><p>
This is wasteful at runtime so C++17 introduced constexpr if statements-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">pi</span> <span class="org-rainbow-delimiters-depth-2">{</span>3.14<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">if</span> <span class="org-keyword">constexpr</span> <span class="org-rainbow-delimiters-depth-2">(</span>pi == 3.14<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"pi is 3.14"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">else</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"pi is not 3.14"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org6ec5a12" class="outline-3">
<h3 id="org6ec5a12"><span class="section-number-3">12.3.</span> The <code>[[fallthrough]]</code> attribute</h3>
<div class="outline-text-3" id="text-12-3">
<ul class="org-ul">
<li>When using switch statements, if we do not use the <code>break</code> or <code>return</code> keyword, the cases following the matched case will also be executed which is known as a fallthrough.</li>
<li>This is not desired mostly but when it is, we can tell the compiler to avoid giving a warning by using the <code>[[fallthrough]]</code> attribute.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">switch</span> <span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-keyword">case</span> 1:
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"1"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">break</span>;
  <span class="org-keyword">case</span> 2:
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"2"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-rainbow-delimiters-depth-4">[</span>fallthrough<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">]</span>;
  <span class="org-keyword">case</span> 3:
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"3"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">break</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Note that the semicolon used along with the <code>[[fallthrough]]</code> attribute is a <code>null</code> statement.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org1680da7" class="outline-3">
<h3 id="org1680da7"><span class="section-number-3">12.4.</span> Halting Programs</h3>
<div class="outline-text-3" id="text-12-4">
<ul class="org-ul">
<li>You can halt a program using <code>std::exit()</code> from <code>cstdlib</code>.</li>
<li>This function does not, however, clean up memory reserved for the local variables.</li>
<li>Always use the <code>std::atexit(callback)</code> function which runs the callback function provided to it whenever <code>std::exit()</code> has been called.</li>
</ul>
<blockquote>
<p>

</p>

<p>
You should <i>never</i> use halt functions explicitly unless there's no safe way to exit the program.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgab0dc68" class="outline-2">
<h2 id="orgab0dc68"><span class="section-number-2">13.</span> Randomness</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li>Algorithms that simulate generating random numbers are called "Pseudo Random Number Generators (PRNGs)".</li>
<li>An initial value called the <code>seed</code> is provided to every PRNG to generate random numbers.</li>
<li>To further generate random numbers, the initial seed is modified by some mathematical calculations and then the new value is used.</li>
<li>The <span class="underline">state</span> of an algorithm is the value that the stateful algorithm keeps.</li>
<li>An algorithm is considered to be stateful if it retains some information across calls.</li>
<li>When, for a PRNG, the size of the seed provided is less than the intended size of the state, the PRNG is said to be <i>underseeded</i>.</li>
<li>Underseeded PRNGs will produce low quality random numbers.</li>
</ul>
</div>
<div id="outline-container-orgd3aef04" class="outline-3">
<h3 id="orgd3aef04"><span class="section-number-3">13.1.</span> Built-in PRNGs in C++</h3>
<div class="outline-text-3" id="text-13-1">
<ul class="org-ul">
<li>In the <code>&lt;random&gt;</code> library, there are 6 PRNGs available for use (as of C++20).</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Type name</th>
<th scope="col" class="org-left">Family</th>
<th scope="col" class="org-left">Period</th>
<th scope="col" class="org-left">State size*</th>
<th scope="col" class="org-left">Performance</th>
<th scope="col" class="org-left">Quality</th>
<th scope="col" class="org-left">Should I use this?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>minstd_rand</code></td>
<td class="org-left">Linear congruential generator</td>
<td class="org-left">2<sup>31</sup></td>
<td class="org-left">4 bytes</td>
<td class="org-left">Bad</td>
<td class="org-left">Awful</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left"><code>minstd_rand0</code></td>
<td class="org-left">Linear congruential generator</td>
<td class="org-left">2<sup>31</sup></td>
<td class="org-left">4 bytes</td>
<td class="org-left">Bad</td>
<td class="org-left">Awful</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">mt19937</td>
<td class="org-left">Mersenne twister</td>
<td class="org-left">2<sup>19937</sup></td>
<td class="org-left">2500 bytes</td>
<td class="org-left">Decent</td>
<td class="org-left">Decent</td>
<td class="org-left">Probably (see next section)</td>
</tr>

<tr>
<td class="org-left"><code>mt19937_64</code></td>
<td class="org-left">Mersenne twister</td>
<td class="org-left">2<sup>19937</sup></td>
<td class="org-left">2500 bytes</td>
<td class="org-left">Decent</td>
<td class="org-left">Decent</td>
<td class="org-left">Probably (see next section)</td>
</tr>

<tr>
<td class="org-left">ranlux24</td>
<td class="org-left">Subtract and carry</td>
<td class="org-left">10<sup>171</sup></td>
<td class="org-left">96 bytes</td>
<td class="org-left">Awful</td>
<td class="org-left">Good</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">ranlux48</td>
<td class="org-left">Subtract and carry</td>
<td class="org-left">10<sup>171</sup></td>
<td class="org-left">96 bytes</td>
<td class="org-left">Awful</td>
<td class="org-left">Good</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">knuth<sub>b</sub></td>
<td class="org-left">Shuffled linear congruential generator</td>
<td class="org-left">2<sup>31</sup></td>
<td class="org-left">1028 bytes</td>
<td class="org-left">Awful</td>
<td class="org-left">Bad</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">default<sub>random</sub><sub>engine</sub></td>
<td class="org-left">Any of above (implementation defined)</td>
<td class="org-left">Varies</td>
<td class="org-left">Varies</td>
<td class="org-left">?</td>
<td class="org-left">?</td>
<td class="org-left">No2</td>
</tr>

<tr>
<td class="org-left">rand()</td>
<td class="org-left">Linear congruential generator</td>
<td class="org-left">2<sup>31</sup></td>
<td class="org-left">4 bytes</td>
<td class="org-left">Bad</td>
<td class="org-left">Awful</td>
<td class="org-left">Nono</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>We should only use the Mersenne twister PRNG out of all the other built-in methods (if you don't have the choice to use third party libraries).</li>
<li><code>mt19937</code> generates 32 bit unsigned integers while <code>mt19937_64</code> generates 64 bit unsigned integers.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">initializing</span>
  <span class="org-constant">std</span>::cout &lt;&lt; mt<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">using mt() is the preferred way to call the mt.operator() method</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>To generate numbers within a range with unbiased results (i.e. each number has an equal chance of being generated), we can use the <code>std::uniform_int_distribution</code> class.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{}</span>;

  <span class="org-constant">std</span>::<span class="org-type">uniform_int_distribution</span> <span class="org-variable-name">dice</span><span class="org-rainbow-delimiters-depth-2">{</span>1,6<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">printing a bunch of random numbers</span>
  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">count</span> <span class="org-rainbow-delimiters-depth-3">{</span>1<span class="org-rainbow-delimiters-depth-3">}</span>; count &lt;= 40; count++<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; dice<span class="org-rainbow-delimiters-depth-3">(</span>mt<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-string">' '</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>We can use <code>std::chrono</code> to seed the PRNG with the current time (it stores the time in "ticks" which is usually in nanoseconds or microseconds!).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">mt19937</span>::result_type<span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-4">()</span>.time_since_epoch<span class="org-rainbow-delimiters-depth-4">()</span>.count<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-constant">std</span>::<span class="org-type">uniform_int_distribution</span> <span class="org-variable-name">dice</span><span class="org-rainbow-delimiters-depth-2">{</span>1,6<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> <span class="org-rainbow-delimiters-depth-3">{</span>1<span class="org-rainbow-delimiters-depth-3">}</span>; i &lt;= 40; i++<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; dice<span class="org-rainbow-delimiters-depth-3">(</span>mt<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-string">' '</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>You can also seed using the system's random device (recommended over system time)-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">std</span>::random_device<span class="org-rainbow-delimiters-depth-3">{}()</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-constant">std</span>::<span class="org-type">uniform_int_distribution</span> <span class="org-variable-name">dice</span><span class="org-rainbow-delimiters-depth-2">{</span>1,6<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> <span class="org-rainbow-delimiters-depth-3">{</span>0<span class="org-rainbow-delimiters-depth-3">}</span>; i &lt; 40; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; dice<span class="org-rainbow-delimiters-depth-2">(</span>mt<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">' '</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
<code>std::random_device</code> also generates random numbers but should not be used as a PRNG because it is implementation defined, may not be available on all platforms, and might produce low quality results on different compilers.
</p>
</blockquote>
<ul class="org-ul">
<li>The internal state of Mersenne twister is 624 bytes in size.</li>
<li>The seeds we provided above were only 4 bytes in size causing the PRNG to be heavily underseeded.</li>
<li><code>std::seed_seq</code> can be used to provide a seed sequence to the PRNG.</li>
<li>We can provide as many random values to <code>std::seed_seq</code> as we want and it generate unbiased seed values with the required size for the PRNG.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">random_device</span> <span class="org-variable-name">rd</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-constant">std</span>::<span class="org-type">seed_seq</span> <span class="org-variable-name">ss</span><span class="org-rainbow-delimiters-depth-2">{</span>rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">8 random integers</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{</span>ss<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">initializing using the seed sequence</span>

  <span class="org-constant">std</span>::<span class="org-type">uniform_int_distribution</span> <span class="org-variable-name">dice</span><span class="org-rainbow-delimiters-depth-2">{</span>1,6<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> <span class="org-rainbow-delimiters-depth-3">{</span>0<span class="org-rainbow-delimiters-depth-3">}</span>; i &lt; 40; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; dice<span class="org-rainbow-delimiters-depth-2">(</span>mt<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">' '</span>;

  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org450ab08" class="outline-2">
<h2 id="org450ab08"><span class="section-number-2">14.</span> Software Testing</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-org185e6d0" class="outline-3">
<h3 id="org185e6d0"><span class="section-number-3">14.1.</span> Informal Testing</h3>
<div class="outline-text-3" id="text-14-1">
<ul class="org-ul">
<li>Informal testing is the process of testing a program by running it and observing its behaviour.</li>
<li>After writing a program, you just run it with a few different inputs and see if it works as expected.</li>
<li>We can write functions that test's the program's functions by comparing their outputs with expected results.</li>
<li>You can also use <code>assert</code> to check if a condition is true and if it isn't, the program will halt.</li>
</ul>
</div>
</div>
<div id="outline-container-orgcf26668" class="outline-3">
<h3 id="orgcf26668"><span class="section-number-3">14.2.</span> Code Coverage</h3>
<div class="outline-text-3" id="text-14-2">
<ul class="org-ul">
<li>Code coverage is a measure of how much of the code is executed when the program is executed while testing.</li>
<li>Similarly, the term <b>statement coverage</b> refers to the percentage of statements that are executed during testing.</li>
<li><b>Branch coverage</b> refers to the percentage of branches that are executed during testing.</li>
<li><b>Loop coverage</b> says that if you have a loop, you should test it with 0, 1, and 2 iterations. If it works for the second iteration, it will work for all other iterations.</li>
</ul>
</div>
</div>
<div id="outline-container-org9f77478" class="outline-3">
<h3 id="org9f77478"><span class="section-number-3">14.3.</span> Symantic Errors</h3>
<div class="outline-text-3" id="text-14-3">
<ul class="org-ul">
<li>Errors that occur when the program is running and are not caught by the compiler (logical type of errors).</li>
<li>Some semantic errors include:
<ul class="org-ul">
<li>Division by zero</li>
<li>Precision errors</li>
<li>Comparison logical errors</li>
<li>Not using blocks for if statements</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga465ee6" class="outline-3">
<h3 id="orga465ee6"><span class="section-number-3">14.4.</span> Detecting and Handling Errors</h3>
<div class="outline-text-3" id="text-14-4">
<ul class="org-ul">
<li>Most of the time, errors are caused because the programmer made some faulty assumptions like the user will always enter a number when the program asks for a number, the student being look up will always be in the database, etc.</li>
</ul>
</div>
</div>
<div id="outline-container-org3afda62" class="outline-3">
<h3 id="org3afda62"><span class="section-number-3">14.5.</span> Handling String Input</h3>
<div class="outline-text-3" id="text-14-5">
</div>
<div id="outline-container-org825b638" class="outline-4">
<h4 id="org825b638"><span class="section-number-4">14.5.1.</span> Error Case 1: Extraction succeeds but input is meaningless</h4>
<div class="outline-text-4" id="text-14-5-1">
<ul class="org-ul">
<li>For example, required input values were "y" or "n" but the input entered was "q".</li>
<li>Solving these is easy. Just use a while loop until the user enters one of the required values.</li>
</ul>
</div>
</div>
<div id="outline-container-org493f623" class="outline-4">
<h4 id="org493f623"><span class="section-number-4">14.5.2.</span> Error Case 2: Input buffer already had some characters</h4>
<div class="outline-text-4" id="text-14-5-2">
<ul class="org-ul">
<li>In cases where the input buffer already had some items.</li>
<li>You can tell the compiler to clear the input buffer after taking input using <code>std::cin.ignore(100, '\n')</code>.</li>
<li>The above method will clear 100 characters out of the buffer OR until the newline is encountered.</li>
<li><p>
To ignore everything upto and including the <code>\n</code>, we use-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">std</span>::cin.ignore<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">numeric_limits</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::streamsize<span class="org-rainbow-delimiters-depth-2">&gt;</span>::max<span class="org-rainbow-delimiters-depth-2">()</span>, <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div></li>
<li><p>
We can use <code>std::cin.peek()</code> to peek at the next character in the input buffer like this-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">char</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-constant">std</span>::cin &gt;&gt; c;

  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span><span class="org-constant">std</span>::cin.eof<span class="org-rainbow-delimiters-depth-3">()</span> &amp;&amp; <span class="org-constant">std</span>::cin.peek<span class="org-rainbow-delimiters-depth-3">()</span> != <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">clear input buffer</span>
    <span class="org-constant">std</span>::cin.ignore<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">numeric_limits</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::streamsize<span class="org-rainbow-delimiters-depth-4">&gt;</span>::max<span class="org-rainbow-delimiters-depth-4">()</span>, <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">continue</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org00c86eb" class="outline-4">
<h4 id="org00c86eb"><span class="section-number-4">14.5.3.</span> Error Case 3: Extraction fails and program goes in an infinite loop</h4>
<div class="outline-text-4" id="text-14-5-3">
<ul class="org-ul">
<li>Whenever an invalid value is present in the input buffer (for example, a <code>char</code> when <code>int</code> was asked), the value stays in the buffer and the program again searches the buffer (going into an infinite loop).</li>
<li><p>
We can prevent this by doing-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cin.fail<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If EOF character was inserted (on pressing Ctrl+D)</span>
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin.eof<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      exit<span class="org-rainbow-delimiters-depth-3">(</span>0<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">shut down the program now</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::cin.clear<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">used to unset the "failbit" after bad input, i.e., putting back to normal mode</span>
  <span class="org-constant">std</span>::cin.ignore<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">numeric_limits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::streamsize<span class="org-rainbow-delimiters-depth-3">&gt;</span>::max<span class="org-rainbow-delimiters-depth-3">()</span>, <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>We can also just test for failure like this- <code>if (!std::cin)</code>.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge032d14" class="outline-3">
<h3 id="orge032d14"><span class="section-number-3">14.6.</span> Assertions</h3>
<div class="outline-text-3" id="text-14-6">
<ul class="org-ul">
<li>Preconditions are the conditions that must be true before a function is called.</li>
<li>An <b>invariant</b> is a condition that must be true while some section of code is executing. This is often used with loops, where the loop body will only execute so long as the invariant is true.</li>
<li>Postconditions are the conditions that must be true after a function is called.</li>
</ul>
</div>
<div id="outline-container-orgc750860" class="outline-4">
<h4 id="orgc750860"><span class="section-number-4">14.6.1.</span> Assert</h4>
<div class="outline-text-4" id="text-14-6-1">
<ul class="org-ul">
<li>An assertion is a statement that which takes a condition which, if false, will print an error message and run <code>std::abort()</code>.</li>
<li><p>
You can use the <code>assert</code> macro to check if a condition is true.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">printAge</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">age</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  assert<span class="org-rainbow-delimiters-depth-2">(</span>age &gt;= 0 &amp;&amp; <span class="org-string">"Age must be positive"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"I am "</span> &lt;&lt; age &lt;&lt; <span class="org-string">" years old"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Assert statements should NOT be used in production code as they come with a performance cost and the program must have already been checked for any errors.</li>
<li>The <code>NDEBUG</code> flag disables assert statements.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd3f9b64" class="outline-4">
<h4 id="orgd3f9b64"><span class="section-number-4">14.6.2.</span> Static Assert</h4>
<div class="outline-text-4" id="text-14-6-2">
<ul class="org-ul">
<li>Instead of a macro, it is a keyword.</li>
<li>It is used to check if a condition is true at <b>compile time</b>.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org3bc52a5" class="outline-2">
<h2 id="org3bc52a5"><span class="section-number-2">15.</span> Type Conversions, Type Aliases, Type Deduction</h2>
<div class="outline-text-2" id="text-15">
</div>
<div id="outline-container-orgf0658f0" class="outline-3">
<h3 id="orgf0658f0"><span class="section-number-3">15.1.</span> Implicit Type Conversions</h3>
<div class="outline-text-3" id="text-15-1">
<ul class="org-ul">
<li>Performed automatically by the compiler.</li>
<li>If the conversion can not be performed, the compiler will throw an error.</li>
</ul>
</div>
<div id="outline-container-org01e9d44" class="outline-4">
<h4 id="org01e9d44"><span class="section-number-4">15.1.1.</span> Numeric Promotions</h4>
<div class="outline-text-4" id="text-15-1-1">
<ul class="org-ul">
<li>A numeric promotion is an implicit type conversion where narrower data types (like char) are converted to wider data types (like int and long) that can be processed efficiently.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org966f194"></a>Floating Point Promotions<br />
<div class="outline-text-5" id="text-15-1-1-1">
<p>
A value of type float is promoted to double.
</p>
</div>
</li>
<li><a id="org737b8c8"></a>Integral Promotions<br />
<div class="outline-text-5" id="text-15-1-1-2">
<p>
A value of type char, signed char, unsigned char, short, or unsigned short is promoted to an int if an int can represent all the values of the original type.
</p>
</div>
</li>
<li><a id="org03a7545"></a>Safe Conversions<br />
<div class="outline-text-5" id="text-15-1-1-3">
<p>
Conversions in which the original value (the meaning) does not change. For example, converting an int to a long.
</p>
</div>
</li>
<li><a id="orgd8c0a9e"></a>Reinterpretative Conversions<br />
<div class="outline-text-5" id="text-15-1-1-4">
<p>
Conversions which are considered unsafe where the result may be outside the range of the source type. This includes signed/unsigned conversions.
</p>
</div>
</li>
<li><a id="org315ad28"></a>Lossy Conversions<br />
<div class="outline-text-5" id="text-15-1-1-5">
<p>
Conversions in which the some/whole part of the original value is lost. For example, converting a double to an int or double with many decimal places to a float (low precision causes loss of some decimal values).
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org2a33355" class="outline-3">
<h3 id="org2a33355"><span class="section-number-3">15.2.</span> Narrowing Conversions</h3>
<div class="outline-text-3" id="text-15-2">
<ul class="org-ul">
<li>From a floating point type to an integer type (unless it's constexpr <i>or</i> decimal places are zero).</li>
<li>From an integral type to a floating type.</li>
<li>From an integral type to a narrower integral type (unless it's constexpr <i>or</i> in range).</li>
<li>These are unsafe and should be avoided.</li>
<li>In some cases, you may want to explicitly do a narrowing conversion. You can do this using the <code>static_cast</code> operator.</li>
</ul>
</div>
</div>
<div id="outline-container-org3bd09d9" class="outline-3">
<h3 id="org3bd09d9"><span class="section-number-3">15.3.</span> Type Aliases</h3>
<div class="outline-text-3" id="text-15-3">
<ul class="org-ul">
<li>We use the <code>using</code> keyword to define type aliases.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">using</span> <span class="org-type">Distance</span> = <span class="org-type">double</span>;
<span class="org-type">Distance</span> <span class="org-variable-name">homeToSchool</span> <span class="org-rainbow-delimiters-depth-1">{</span>3.55<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>It's a convention to name aliases starting with a capital letter.</li>
<li>We can also use <code>typedef</code> from C in C++ (but it's only present for backwards compatibility and its syntax can get very confusing).</li>
<li>The <code>std::int8_t</code> type is just an alias to <code>char</code> which is exactly why we get a character value when using it.</li>
</ul>
</div>
</div>
<div id="outline-container-org46bdd33" class="outline-3">
<h3 id="org46bdd33"><span class="section-number-3">15.4.</span> Type Deduction</h3>
<div class="outline-text-3" id="text-15-4">
<ul class="org-ul">
<li>We defining a variable, for example <code>double distance {5.76};</code>, the literal <code>5.76</code> has the type double and we have explicitly mentioned <code>double</code> as the data type of <code>distance</code>, providing the same information twice.</li>
<li>The compiler can deduce the type automatically in such cases using- <code>auto distance {5.76};</code></li>
<li><p>
Type deduction doesn't work if the return value of a function is void, for example-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">void</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">test</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span>test<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Not valid</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>Using <code>auto</code> will drop <code>const</code> and <code>constexpr</code> from the type.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">num</span> <span class="org-rainbow-delimiters-depth-1">{</span>5<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-1">{</span>num<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">a is of type int, not constexpr int</span>

<span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">b</span> <span class="org-rainbow-delimiters-depth-1">{</span>num<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">b is of type constexpr int</span>
</pre>
</div>
<ul class="org-ul">
<li>Normal string literals default to the type <code>const char*</code>, so to use <code>std::string</code> or <code>std::string_view</code>, use literal suffixes- <code>"hello"std::literals::s</code> or <code>"hello"std::literals::sv</code>.</li>
<li>In such cases, it may be better to not use <code>auto</code> and just use the type explicitly.</li>
<li><p>
You can also use <code>auto</code> with functions, however this is NOT recommended.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">auto</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> a + b;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li><p>
The following is also valid
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">auto</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> a + b;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>Type deductions can't be used for function parameters, like <code>int add(auto a, autob);</code> is not valid.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org88b1616" class="outline-2">
<h2 id="org88b1616"><span class="section-number-2">16.</span> Function Overloading</h2>
<div class="outline-text-2" id="text-16">
<ul class="org-ul">
<li>Function overloading is the process of defining multiple functions with the same name but different parameters.</li>
<li>The compiler will choose the function to call based on the type of the parameters.</li>
<li>Function overloading is allowed so long as the compiler can differntiate between the functions (else, compiler error).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-type">int</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">result</span> = a + b;
  <span class="org-keyword">return</span> result;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">double</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">double</span> <span class="org-variable-name">result</span> = a + b;
  <span class="org-keyword">return</span> result;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; add<span class="org-rainbow-delimiters-depth-2">(</span>5, 3<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; add<span class="org-rainbow-delimiters-depth-2">(</span>5.5, 3.3<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Unexpectedly, there are no downsides to function overloading and it can/should be used liberally.</li>
</ul>
</div>
<div id="outline-container-orgedcd7b8" class="outline-3">
<h3 id="orgedcd7b8"><span class="section-number-3">16.1.</span> Function Overload Differentiation</h3>
<div class="outline-text-3" id="text-16-1">
<ul class="org-ul">
<li>The compiler differentiates between functions by looking at the <b>number of parameters</b> and their <b>types</b>.</li>
<li>The return type of a function is not considered when differentiating between functions.</li>
<li>Qualifiers like <code>const</code> are also not considered when differentiating between functions.</li>
</ul>
</div>
</div>
<div id="outline-container-org976c85f" class="outline-3">
<h3 id="org976c85f"><span class="section-number-3">16.2.</span> Resolving Overloaded Function Calls</h3>
<div class="outline-text-3" id="text-16-2">
<ul class="org-ul">
<li>Resolving overloaded function calls is the process of the compiler choosing which function to call when an overloaded function is called.</li>
<li>It goes through these steps-
<ol class="org-ol">
<li>The compiler will look for an exact match for the function call.</li>
<li>If step 1 fails, the compiler will perform numeric promotions and look for a match.</li>
<li>If step 2 fails, the compiler will perform numeric conversions and look for a match.</li>
<li>If step 3 fails, the compiler will look for a match using the user-defined conversions.</li>
<li>If step 4 fails, the compiler will look for a matching function that uses ellipsis.</li>
<li>If step 5 fails, the compiler will throw an error.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orga4c7ec9" class="outline-3">
<h3 id="orga4c7ec9"><span class="section-number-3">16.3.</span> Deleting Functions</h3>
<div class="outline-text-3" id="text-16-3">
<ul class="org-ul">
<li>You can prohibit certain function calls by using the <code>delete</code> keyword.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-type">int</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> a + b;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span> <span class="org-variable-name">a</span>, <span class="org-type">char</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-keyword">delete</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">if called, the program will not compile</span>
<span class="org-type">void</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-keyword">delete</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">if called, the program will not compile</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  add<span class="org-rainbow-delimiters-depth-2">(</span>5, 3<span class="org-rainbow-delimiters-depth-2">)</span>;
  add<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'a'</span>, <span class="org-string">'b'</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will not compile</span>
  add<span class="org-rainbow-delimiters-depth-2">(</span>5.5, 3.3<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will not compile</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org94ec698" class="outline-3">
<h3 id="org94ec698"><span class="section-number-3">16.4.</span> Default Arguments</h3>
<div class="outline-text-3" id="text-16-4">
<ul class="org-ul">
<li>Default arguments are used to provide a default value for a function parameter.</li>
<li>The default arguments should be specified in forward declarations (function prototype) and not in the function definition.</li>
<li>Example: <code>int add(int a, int b = 0);</code></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1d2684e" class="outline-2">
<h2 id="org1d2684e"><span class="section-number-2">17.</span> Function Templates</h2>
<div class="outline-text-2" id="text-17">
<ul class="org-ul">
<li>The generic type is specified using a template parameter.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">T</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">a</span>, <span class="org-type">T</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> a + b;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>The <code>typename</code> or the <code>class</code> keyword is used to specify a template parameter (it doesn't matter if you use <code>class</code> or <code>typename</code>, both mean the same).</li>
<li>A function template is used to generate functions. Function templates themselves are not functions.</li>
<li>We can call the add function doing something like this- <code>add&lt;int&gt;(5, 6)</code>. The compiler will see that a function definition for <code>add</code> does not already exist, so it will generate one.</li>
<li>When the data types of arguments matches the typename of the template, we can simply let the compiler deduce the typename doing something like this- <code>add&lt;&gt;(5, 6)</code> or simply <code>add(5,6)</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">T</span> <span class="org-function-name">getMax</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">a</span>, <span class="org-type">T</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>a &gt; b<span class="org-rainbow-delimiters-depth-2">)</span> ? a : b;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">char</span> <span class="org-function-name">getMax</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span> <span class="org-variable-name">a</span>, <span class="org-type">char</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>a &gt; b<span class="org-rainbow-delimiters-depth-2">)</span> ? a : b;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getMax<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>5, 10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">calls getMax&lt;int&gt;(int, int)</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getMax<span class="org-rainbow-delimiters-depth-2">&lt;&gt;(</span>5, 10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">calls getMax&lt;int&gt;(int, int), not template functions are not considered</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getMax<span class="org-rainbow-delimiters-depth-2">(</span>5, 10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">will call getMax(char, char)</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
<div id="outline-container-orgdbd7f4b" class="outline-3">
<h3 id="orgdbd7f4b"><span class="section-number-3">17.1.</span> Forward Declaring Function Templates</h3>
<div class="outline-text-3" id="text-17-1">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span>
<span class="org-type">T</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">a</span>, <span class="org-type">T</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org7e277bb" class="outline-3">
<h3 id="org7e277bb"><span class="section-number-3">17.2.</span> Including Function Templates</h3>
<div class="outline-text-3" id="text-17-2">
<ul class="org-ul">
<li>You can define function templates inside header files since they are exempted from the one definition rule.</li>
<li>This allows the compiler to see the full definition of the template and instantiate functions whenever needed.</li>
<li>Using forward declarations won't work for function templates.</li>
</ul>
</div>
</div>
<div id="outline-container-org349d745" class="outline-3">
<h3 id="org349d745"><span class="section-number-3">17.3.</span> Abbreviated Function Templates</h3>
<div class="outline-text-3" id="text-17-3">
<ul class="org-ul">
<li>For C++20 and above only.</li>
<li><p>
Defines a simple shorthand to create function templates-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">This is a shorthand to the template definition below</span>
<span class="org-keyword">auto</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">a</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> a + b;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">The above is the shorthand to this</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-type">U</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">audo</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">a</span>, <span class="org-type">U</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> a + b;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org8827b30" class="outline-3">
<h3 id="org8827b30"><span class="section-number-3">17.4.</span> Non-type Template Parameters</h3>
<div class="outline-text-3" id="text-17-4">
<ul class="org-ul">
<li>A template parameter used to represent a <code>constexpr</code> value.</li>
<li>The following types are accepted as template parameters-
<ol class="org-ol">
<li>Integral types</li>
<li>Enumeration type</li>
<li>Floating Point type (since C++20)</li>
<li>Literal class types (since C++20)</li>
<li>Etc&#x2026;</li>
</ol></li>
<li>From C++17 onwards, you can use the <code>auto</code> keyword to automatically let the compiler deduce the non-type template parameter from the template argument.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span> <span class="org-variable-name">N</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; N &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  print<span class="org-rainbow-delimiters-depth-2">&lt;</span>5<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6a0614f" class="outline-2">
<h2 id="org6a0614f"><span class="section-number-2">18.</span> References</h2>
<div class="outline-text-2" id="text-18">
</div>
<div id="outline-container-orga74661b" class="outline-3">
<h3 id="orga74661b"><span class="section-number-3">18.1.</span> Lvalue and Rvalue Expressions</h3>
<div class="outline-text-3" id="text-18-1">
<ul class="org-ul">
<li>Rvalue expressions are expressions which evaluate to a value.</li>
<li>Lvalue expressions are expressions which evaluate to identifiable objects.</li>
</ul>
<blockquote>
<p>
If you're not sure if an expression is an lvalue or not, remember that all lvalues can be referenced using the <code>&amp;</code> operator while rvalues can not.
For example, <code>&amp;x</code>, where <code>x</code> is a variable (something like <code>&amp;5</code> won't work since 5 is an rvalue expression).
</p>
</blockquote>
<ul class="org-ul">
<li>Lvalue expressions are implicitly converted to rvalue expressions when they are provided in places where rvalues were expected.</li>
<li>Lvalues are of two types, modifiable (non-const) and non-modifiable (<code>const</code>).</li>
<li>C-style string literalls are rvalues.</li>
</ul>
</div>
</div>
<div id="outline-container-org48b78ae" class="outline-3">
<h3 id="org48b78ae"><span class="section-number-3">18.2.</span> Lvalue References</h3>
<div class="outline-text-3" id="text-18-2">
<ul class="org-ul">
<li>An lvalue reference acts as an alias for an existing lvalue.</li>
<li><p>
It is declared using the <code>&amp;</code> operator
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-comment-delimiter">// </span><span class="org-comment">int type</span>
<span class="org-type">int</span>&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">lvalue reference to an int</span>
<span class="org-type">double</span>&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">lvalue reference to a double</span>
</pre>
</div></li>
<li>We can create lvalue reference variables like this</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-1">{</span>10<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">referenceToAge</span> <span class="org-rainbow-delimiters-depth-1">{</span>age<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>References <i>must</i> always be initialized.</li>
<li>Once initialized, a reference can not be changed to refer to another object.</li>
<li>References are not objects in C++. They aren't required to be stored in memory. The compiler might also replace all occurances of the reference with the referent to optimize.</li>
<li>The above point is the reason why you can <i>not</i> have references to references in C++.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span>10<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">ref</span> <span class="org-rainbow-delimiters-depth-1">{</span>x<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">reference to x</span>
<span class="org-type">int</span>&amp; <span class="org-variable-name">ref2</span> <span class="org-rainbow-delimiters-depth-1">{</span>ref<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this will work because it's NOT a reference to ref, it's a reference to x</span>
</pre>
</div>
<ul class="org-ul">
<li>Lvalue references can not bind to non-modifiable lvalues (non-const).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span>10<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">ref</span> <span class="org-rainbow-delimiters-depth-1">{</span>x<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">not allowed</span>
</pre>
</div>
<ul class="org-ul">
<li>Type deductions using the <code>auto</code> keyword will drop references.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span>10<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-1">{</span>x<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">reference to x</span>

<span class="org-keyword">auto</span> <span class="org-variable-name">z</span> <span class="org-rainbow-delimiters-depth-1">{</span>y<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">z is of type int, not int&amp;</span>
<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">z2</span> <span class="org-rainbow-delimiters-depth-1">{</span>y<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">z2 is of type int&amp;</span>
</pre>
</div>
<ul class="org-ul">
<li>Type deductions using <code>auto</code> will drop references first and only then it will drop top-level consts.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-function-name">getConstRef</span><span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">some function that returns a const reference</span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">ref1</span><span class="org-rainbow-delimiters-depth-2">{</span> getConstRef<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span>;        <span class="org-comment-delimiter">// </span><span class="org-comment">std::string (reference and top-level const dropped)</span>
    <span class="org-keyword">const</span> <span class="org-keyword">auto</span> <span class="org-variable-name">ref2</span><span class="org-rainbow-delimiters-depth-2">{</span> getConstRef<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string (reference dropped, const reapplied)</span>
    <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">ref3</span><span class="org-rainbow-delimiters-depth-2">{</span> getConstRef<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string&amp; (reference reapplied, low-level const not dropped)</span>
    <span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">ref4</span><span class="org-rainbow-delimiters-depth-2">{</span> getConstRef<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string&amp; (reference and const reapplied)</span>
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org27f2060" class="outline-3">
<h3 id="org27f2060"><span class="section-number-3">18.3.</span> Dangling References</h3>
<div class="outline-text-3" id="text-18-3">
<ul class="org-ul">
<li>When the object that a reference refers to is destroyed, the reference becomes a dangling reference.</li>
</ul>
</div>
</div>
<div id="outline-container-orgbeab874" class="outline-3">
<h3 id="orgbeab874"><span class="section-number-3">18.4.</span> Lvalue references to const</h3>
<div class="outline-text-3" id="text-18-4">
<ul class="org-ul">
<li>To make lvalue references bind to non-modifiable lvalues, use the <code>const</code> keyword.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span>10<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">ref</span> <span class="org-rainbow-delimiters-depth-1">{</span>x<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">allowed</span>

<span class="org-type">int</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-1">{</span>20<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">ref2</span> <span class="org-rainbow-delimiters-depth-1">{</span>y<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">allowed, but ref2 can not be used to modify y</span>
</pre>
</div>

<blockquote>
<p>
Always use lvalue references to const when you don't need to modify the referent.
</p>
</blockquote>
<ul class="org-ul">
<li><p>
Lvalue references to const can also bind to rvalues.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">ref</span> <span class="org-rainbow-delimiters-depth-1">{</span>5<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">allowed</span>
</pre>
</div></li>
<li>In the above example, a temporary object will be created to store the value 5 and the reference will bind to that temporary object.</li>
<li>This will increase the lifetime of the temporary object to the lifetime of the reference.</li>
</ul>
</div>
</div>
<div id="outline-container-org030e4a0" class="outline-3">
<h3 id="org030e4a0"><span class="section-number-3">18.5.</span> Pass Values by Reference To Functions</h3>
<div class="outline-text-3" id="text-18-5">
<ul class="org-ul">
<li>Reduces the overhead of copying large objects.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">void</span> <span class="org-function-name">hello</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; name &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Hello World"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  hello<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>
As a rule of thumb, pass fundamental types by value and class (or struct) types by references.
Other common types to pass by value: enumerated types and std::string<sub>view</sub>.
Other common types to pass by (const) reference: std::string, std::array, and std::vector.
</p>
</blockquote>
<ul class="org-ul">
<li>For objects that are cheap to copy, the cost of copying is similar to the cost of binding, so we favor pass by value so the code generated will be faster.</li>
<li>For objects that are expensive to copy, the cost of the copy dominates, so we favor pass by (const) reference to avoid making a copy.</li>
<li><code>std::string_view</code> is better than <code>std::string&amp;</code> because when passing different types of strings (c-style string literals, string<sub>view</sub>, string), the <code>std::string_view</code> will be able to reference all those types easily, while passing types other than <code>std::string</code> to a <code>std::string&amp;</code> will require the compiler to make a temporary <code>std::string</code> object (by implicit conversion or copy).</li>
</ul>
</div>
<div id="outline-container-org3de749c" class="outline-4">
<h4 id="org3de749c"><span class="section-number-4">18.5.1.</span> </h4>
</div>
</div>
<div id="outline-container-org7309e0e" class="outline-3">
<h3 id="org7309e0e"><span class="section-number-3">18.6.</span> Return by Reference</h3>
<div class="outline-text-3" id="text-18-6">
<ul class="org-ul">
<li>When returning values from a function, a copy is returned.</li>
<li>This may be expensive for class types.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-comment-delimiter">// </span><span class="org-comment">notice the ampersand (&amp;) in the return type</span>
<span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{</span>20<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">destroyed at the end of the program</span>
  <span class="org-keyword">return</span> age;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; foo<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<blockquote>
<p>
Avoid returning non-const static values as references.
</p>
</blockquote>
<ul class="org-ul">
<li>Initializing a reference returned by a function to a non reference variable will make a copy of the return value which defeats the entire purpose of returning a reference.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{</span>20<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> age;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{</span>foo<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">BAD: Defeats the purpose of returning reference from foo()</span>
  <span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">age2</span> <span class="org-rainbow-delimiters-depth-2">{</span>foo<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">GOOD</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org28d3ad6" class="outline-3">
<h3 id="org28d3ad6"><span class="section-number-3">18.7.</span> In-Out Parameters</h3>
<div class="outline-text-3" id="text-18-7">
<ul class="org-ul">
<li>Parameters which are used to receive input from the function caller are called in parameters.</li>
<li>Parameters which are used to send output to the function caller are called out parameters (for example, references and pointers which are used to modify the original object from inside the function).</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb5cf7f7" class="outline-2">
<h2 id="orgb5cf7f7"><span class="section-number-2">19.</span> Pointers</h2>
<div class="outline-text-2" id="text-19">
<ul class="org-ul">
<li>Always initialize your pointers, for example, <code>int* a{&amp;x};</code>.</li>
<li>Unlike references, pointers <i>are</i> objects and they require space in memory to exist.</li>
<li>References are safer than pointers (which are inherently dangerous).</li>
<li>The size of a pointer depends on the architecture the program's being compiled for. On a 32-bit machine, a pointer will be 32 bit in size and 64bits on a 64-bit machine.</li>
</ul>
</div>
<div id="outline-container-orgb45e8f8" class="outline-3">
<h3 id="orgb45e8f8"><span class="section-number-3">19.1.</span> Dangling Pointers</h3>
<div class="outline-text-3" id="text-19-1">
<ul class="org-ul">
<li>Pointers which store invalid addresses are called dangling pointers.</li>
<li>Dereferencing such pointers leads to undefined behaviour.</li>
</ul>
</div>
</div>
<div id="outline-container-org73a7dfd" class="outline-3">
<h3 id="org73a7dfd"><span class="section-number-3">19.2.</span> Null Pointers</h3>
<div class="outline-text-3" id="text-19-2">
<ul class="org-ul">
<li>Can be initialized using direct list initialization like this- <code>int* ptr {};</code></li>
<li>They don't point to any address.</li>
<li>Can later be assigned an address.</li>
<li>We can use the <code>nullptr</code> <i>literal</i> to initialize a null pointer explicitly- <code>int* ptr {nullptr};</code></li>
<li><code>nullptr</code> has the type <code>std::nullptr_t</code>. So whenever nullptr is used to initialize a pointer variable, it is implicitly converted from <code>std::nullptr_t</code> to the required type.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span>* <span class="org-variable-name">ptr</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">can initialize using nullptr</span>
  <span class="org-type">int</span>* <span class="org-variable-name">anotherPtr</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

  anotherPtr = <span class="org-constant">nullptr</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">can also assign to nullptr literal later</span>

  foo<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">can also pass nullptr literal to functions</span>
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>ptr == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"No"</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">null pointers (nullptr) are implicitly converted to boolean value FALSE and pointers that hold addresses to TRUE</span>
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The pointer, the pointer is real"</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Dereferencing a null pointer also results in undefined behaviour.</li>
</ul>
</div>
</div>
<div id="outline-container-org320fead" class="outline-3">
<h3 id="org320fead"><span class="section-number-3">19.3.</span> Pointer to a Const</h3>
<div class="outline-text-3" id="text-19-3">
<ul class="org-ul">
<li>You can not assign a non-const pointer to a const variable.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-1">{</span>5<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>* <span class="org-variable-name">agePtr</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;age<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">compile error!!</span>

<span class="org-keyword">const</span> <span class="org-type">int</span>* <span class="org-variable-name">agePtr2</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;age<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will work!</span>
agePtr2 = <span class="org-rainbow-delimiters-depth-1">{</span>&amp;someOtherVariable<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will still work!</span>
</pre>
</div>
<ul class="org-ul">
<li>A <b>pointer to a const</b> is <b>not</b> a const itself, so you can change the address it is pointing to.</li>
<li>A <b>pointer to a const</b>, when pointing to a non-const variable will not allow you to modify the value at the address it is pointing to.</li>
</ul>
</div>
</div>
<div id="outline-container-orgf36a3e1" class="outline-3">
<h3 id="orgf36a3e1"><span class="section-number-3">19.4.</span> Const Pointers</h3>
<div class="outline-text-3" id="text-19-4">
<ul class="org-ul">
<li>This is different from a <b>pointer to a const</b>.</li>
<li>A const pointer is a pointer whose address can not be changed once initialized.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-1">{</span>5<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>* <span class="org-keyword">const</span> <span class="org-variable-name">agePtr</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;age<span class="org-rainbow-delimiters-depth-1">}</span>;

agePtr = <span class="org-rainbow-delimiters-depth-1">{</span>&amp;someOtherVariable<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">NOT ALLOWED</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5585b3b" class="outline-3">
<h3 id="org5585b3b"><span class="section-number-3">19.5.</span> Const Pointer to a Const Variable</h3>
<div class="outline-text-3" id="text-19-5">
<ul class="org-ul">
<li>The combination of both the above!</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-1">{</span>5<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">const</span> <span class="org-type">int</span>* <span class="org-keyword">const</span> <span class="org-variable-name">agePtr</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;age<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>Just like normal <b>pointer to const variables</b>, the referents don't have to be const.</li>
</ul>
</div>
</div>
<div id="outline-container-orge2a4035" class="outline-3">
<h3 id="orge2a4035"><span class="section-number-3">19.6.</span> Passing Values to Functions By Address</h3>
<div class="outline-text-3" id="text-19-6">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>* <span class="org-variable-name">num</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; *num &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{</span>5<span class="org-rainbow-delimiters-depth-2">}</span>;
  foo<span class="org-rainbow-delimiters-depth-2">(</span>&amp;age<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>
Prefer using references instead of pointers wherever possible.
</p>
</blockquote>
<ul class="org-ul">
<li>Passing by address copies the address from the caller to the function.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd90ff5b" class="outline-3">
<h3 id="orgd90ff5b"><span class="section-number-3">19.7.</span> Setting Optional Parameters in Functions</h3>
<div class="outline-text-3" id="text-19-7">
<ul class="org-ul">
<li>We can use <code>nullptr</code> to set optional parameters in functions.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span>* <span class="org-variable-name">bar</span>=<span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>bar<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::cout &lt;&lt; *bar;
  <span class="org-keyword">else</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"No"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Function overloading is a better way to achive the same result.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">bar</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; bar;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"No"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf7da16a" class="outline-3">
<h3 id="orgf7da16a"><span class="section-number-3">19.8.</span> Top Level and Low Level Consts</h3>
<div class="outline-text-3" id="text-19-8">
<ul class="org-ul">
<li>Consts that apply to the object itself are called top level consts. For example, <code>const int x {5};</code>.</li>
<li>Consts that apply to the reference or pointer to the object are called low level consts. For example, <code>int const* ptr {&amp;x};</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span>10<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">const</span> <span class="org-type">int</span>* <span class="org-keyword">const</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;z<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">the left const is low level, the right const is top level</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org27c7fad" class="outline-3">
<h3 id="org27c7fad"><span class="section-number-3">19.9.</span> Auto and Pointers</h3>
<div class="outline-text-3" id="text-19-9">
</div>
<div id="outline-container-org828d5d7" class="outline-4">
<h4 id="org828d5d7"><span class="section-number-4">19.9.1.</span> <span class="todo TODO">TODO</span> Read chapter 12.14 again!</h4>
<div class="outline-text-4" id="text-19-9-1">
<ul class="org-ul">
<li>When using the auto keyword, the pointer type is not dropped, only top level consts are dropped.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-1">{}</span>;
<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-keyword">const</span> <span class="org-variable-name">ptr</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;s<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">statement // final type deduced</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">ptr1</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string*</span>
<span class="org-keyword">auto</span>* <span class="org-variable-name">ptr2</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string*</span>

<span class="org-keyword">const</span> <span class="org-keyword">auto</span> <span class="org-variable-name">ptr3</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string* const</span>
<span class="org-keyword">auto</span> <span class="org-keyword">const</span> <span class="org-variable-name">ptr4</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string* const</span>

<span class="org-keyword">auto</span>* <span class="org-keyword">const</span> <span class="org-variable-name">ptr5</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string* const</span>
<span class="org-keyword">const</span> <span class="org-keyword">auto</span>* <span class="org-variable-name">ptr6</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string*</span>

<span class="org-keyword">const</span> <span class="org-keyword">auto</span> <span class="org-keyword">const</span> <span class="org-variable-name">ptr7</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">error, const is used twice</span>
<span class="org-keyword">const</span> <span class="org-keyword">auto</span>* <span class="org-keyword">const</span> <span class="org-variable-name">ptr8</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string* const</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org8e3bc3c" class="outline-2">
<h2 id="org8e3bc3c"><span class="section-number-2">20.</span> User Defined Types</h2>
<div class="outline-text-2" id="text-20">
<p>
These include
</p>
<ol class="org-ol">
<li>Enumerated Types</li>
<li>Class Types
<ol class="org-ol">
<li>Structs</li>
<li>Classes</li>
<li>Unions</li>
</ol></li>
</ol>
<blockquote>
<p>

</p>

<p>
Compilers need to see the full definition of user defined types. So, try to make a separate header file with the same name as the type and include it wherever you need to use it.
</p>
</blockquote>
<p>
The C++ language standard defines a user-defined type as any class or enumerated type defined by you, the standard library or the implementation. This means that even <code>std::string</code> is considered a user defined type.
</p>
</div>
<div id="outline-container-org72d6a3b" class="outline-3">
<h3 id="org72d6a3b"><span class="section-number-3">20.1.</span> Enumeration Types</h3>
<div class="outline-text-3" id="text-20-1">
</div>
<div id="outline-container-org5cb2764" class="outline-4">
<h4 id="org5cb2764"><span class="section-number-4">20.1.1.</span> Unscoped Enumerations</h4>
<div class="outline-text-4" id="text-20-1-1">
<ul class="org-ul">
<li>They are defined using the <code>enum</code> keyword.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span> = 5, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 5</span>
  <span class="org-variable-name">green</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 6</span>
  <span class="org-variable-name">blue</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 7</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Now, we can use Color as a data type</span>
  <span class="org-type">Color</span> <span class="org-variable-name">apple</span> <span class="org-rainbow-delimiters-depth-2">{</span>red<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">Color</span> <span class="org-variable-name">shirt</span> <span class="org-rainbow-delimiters-depth-2">{</span>blue<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-type">Color</span> <span class="org-variable-name">ball</span> <span class="org-rainbow-delimiters-depth-2">{</span>2<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">ERROR because 2 is not a part of the enum Color</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">namespace</span> <span class="org-constant">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">enum</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-variable-name">red</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 0</span>
    <span class="org-variable-name">green</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 1</span>
    <span class="org-variable-name">blue</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 2</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">Color</span>::<span class="org-type">Color</span> <span class="org-variable-name">apple</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">Color</span>::red<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">notice the data type and the enumerator</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="org9ceadae"></a>Enumeration Size or Underlying Type<br />
<div class="outline-text-5" id="text-20-1-1-1">
<ul class="org-ul">
<li>This is the specific type used to represent the integral values held by the enumerators.</li>
<li>Default type depends on the compiler but is mostly <code>int</code>.</li>
<li>You might want to use a different type to save bandwidth or any other reason-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-type">Color</span> : <span class="org-constant">std</span>::int8_t <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span>,
  <span class="org-variable-name">green</span>,
  <span class="org-variable-name">blue</span>,
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Do this only when necessary.</li>
<li>If we specify the type like this, we can <b>list initialize</b> the variable using integer literals.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-type">Color</span> : <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span>,
  <span class="org-variable-name">green</span>,
  <span class="org-variable-name">blue</span>,
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Color</span> <span class="org-variable-name">apple</span> <span class="org-rainbow-delimiters-depth-2">{</span>0<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">okay, list initialization is allowed if type is specified.</span>
  <span class="org-type">Color</span> <span class="org-variable-name">shirt</span> <span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">compile error, copy initialization not allowed with integer literals</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgbc1f85d" class="outline-4">
<h4 id="orgbc1f85d"><span class="section-number-4">20.1.2.</span> Scoped Enumerations</h4>
<div class="outline-text-4" id="text-20-1-2">
<ul class="org-ul">
<li>Similar to unscoped but they prevent the following two things-
<ol class="org-ol">
<li>They don't implicitly convert to integers</li>
<li>They are only placed in the scope region of the enumeration</li>
</ol></li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span>,
  <span class="org-variable-name">green</span>,
  <span class="org-variable-name">blue</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Color</span> <span class="org-variable-name">apple</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">Color</span>::red<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">Color</span> <span class="org-variable-name">shirt</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">Color</span>::blue<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Since they don't implicitly convert to integers, you can not print them onto the screen using <code>std::cout</code>. You can use C++23's <code>std::to_underlying(Color::red)</code> or a normal static conversion to print them.</li>
<li>From C++20 onwards, we can do the following-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span>,
  <span class="org-variable-name">green</span>,
  <span class="org-variable-name">blue</span>,
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-type">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">using</span> <span class="org-keyword">enum</span> Color;
  <span class="org-type">Color</span> <span class="org-variable-name">car</span> <span class="org-rainbow-delimiters-depth-2">{</span>red<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no need to use the scope resolution operator ::</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd794fe3" class="outline-3">
<h3 id="orgd794fe3"><span class="section-number-3">20.2.</span> Class Types</h3>
<div class="outline-text-3" id="text-20-2">
</div>
<div id="outline-container-org4acaaa1" class="outline-4">
<h4 id="org4acaaa1"><span class="section-number-4">20.2.1.</span> Structs</h4>
<div class="outline-text-4" id="text-20-2-1">
<ul class="org-ul">
<li>These are program defined types.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">double</span> <span class="org-variable-name">wage</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">no need to use "struct Employee john" unlike C</span>
  <span class="org-type">Employee</span> <span class="org-variable-name">john</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>The variables inside a struct are called data members.</li>
<li>Structs are of aggregate type meaning they store multiple data members (these include C-style arrays, structs, std::array, etc).</li>
<li>Structs require aggregate initialization like this-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">Employee</span> <span class="org-variable-name">john</span> <span class="org-rainbow-delimiters-depth-1">{</span>1, 24, 50000.0<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">direct list initialization (preferred)</span>
<span class="org-type">Employee</span> <span class="org-variable-name">doe</span> = <span class="org-rainbow-delimiters-depth-1">{</span>2, 24, 60000.0<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">copy list initialization</span>
</pre>
</div>
<ul class="org-ul">
<li>If we leave the list empty (<code>Employee john {};</code>) when initializing a struct type, it will get value initialized (0 for integral types, "" for string etc..).</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org7529a90"></a>Designated Initializers<br />
<div class="outline-text-5" id="text-20-2-1-1">
<ul class="org-ul">
<li>Only for C++20 and above.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">double</span> <span class="org-variable-name">wage</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-type">Employee</span> <span class="org-variable-name">tenma</span> <span class="org-rainbow-delimiters-depth-2">{</span> .id<span class="org-rainbow-delimiters-depth-3">{</span>1<span class="org-rainbow-delimiters-depth-3">}</span>, .age<span class="org-rainbow-delimiters-depth-3">{</span>24<span class="org-rainbow-delimiters-depth-3">}</span>, .wage<span class="org-rainbow-delimiters-depth-3">{</span>60000.0<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">ok</span>
  <span class="org-type">Employee</span> <span class="org-variable-name">johan</span> <span class="org-rainbow-delimiters-depth-2">{</span> .id<span class="org-rainbow-delimiters-depth-3">{</span>2<span class="org-rainbow-delimiters-depth-3">}</span>, .wage<span class="org-rainbow-delimiters-depth-3">{</span>60000.0<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">ok, age is value initialized (0)</span>
  <span class="org-type">Employee</span> <span class="org-variable-name">anna</span> <span class="org-rainbow-delimiters-depth-2">{</span> .wage<span class="org-rainbow-delimiters-depth-3">{</span>60000.0<span class="org-rainbow-delimiters-depth-3">}</span>, .id<span class="org-rainbow-delimiters-depth-3">{</span>3<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">error, order does not match</span>
  <span class="org-constant">std</span>::cout &lt;&lt; john.wage &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Do not use designated initializers to prevent clutter. Use the normal way and if you need to add new data members, add them to the end so order won't mix up.
</p>
</blockquote>
</div>
</li>
<li><a id="orgd036ffd"></a>Designated Assignment<br />
<div class="outline-text-5" id="text-20-2-1-2">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">double</span> <span class="org-variable-name">wage</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-type">Employee</span> <span class="org-variable-name">tenma</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  tenma = <span class="org-rainbow-delimiters-depth-2">{</span>.id = 1, .age = 32, .wage = 50000.0<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; john.wage &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="orge9344e2"></a>Default Member Initialization<br />
<div class="outline-text-5" id="text-20-2-1-3">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Something</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">first</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">bad</span>
  <span class="org-type">int</span> <span class="org-variable-name">second</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">0 initialized</span>
  <span class="org-type">int</span> <span class="org-variable-name">third</span> <span class="org-rainbow-delimiters-depth-2">{</span>5<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">default value 5</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Something</span> <span class="org-variable-name">thing</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">first is value initialized to 0, second has default member 0, third is 5</span>
  <span class="org-constant">std</span>::cout &lt;&lt; thing.first &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-type">Something</span> <span class="org-variable-name">anotherThing</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">not initialized (bad)</span>
  <span class="org-constant">std</span>::cout &lt;&lt; anotherThing.first &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">garbage value since it's not value initialized</span>
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Always provide a default value to each member of structs.
</p>
</blockquote>
</div>
</li>
<li><a id="org43aa206"></a>Passing/Returning Structs From/To Functions<br />
<div class="outline-text-5" id="text-20-2-1-4">
<ul class="org-ul">
<li>Always try to pass structs by references or pointers to avoid making copies.</li>
<li>When passing by reference, you can access properties by using <code>.</code> like <code>thing.first</code>.</li>
<li>When passing by pointers, you have to access properties by using <code>-&gt;</code> like <code>thing-&gt;first</code>.</li>
<li>When returning, it is not necessary to create a temporary object and then return it.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-2">{</span>0<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-2">{</span>0<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">z</span> <span class="org-rainbow-delimiters-depth-2">{</span>0<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">It returns point with default initialized members</span>
<span class="org-type">Point</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">You can also do something like this</span>
  <span class="org-comment-delimiter">/*</span>
<span class="org-comment">   * return Point {}; </span>
<span class="org-comment">   * return {1, 2, 3}; </span>
<span class="org-comment-delimiter">   */</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org976cd15"></a>Nested Structs<br />
<div class="outline-text-5" id="text-20-2-1-5">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">Company</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">struct</span> <span class="org-type">CEO</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
    <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">numberOfEmployees</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">CEO</span> <span class="org-variable-name">companyCEO</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Company</span> <span class="org-variable-name">myCompany</span> <span class="org-rainbow-delimiters-depth-2">{</span>50000, <span class="org-rainbow-delimiters-depth-3">{</span>0, 20<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; myCompany.companyCEO.age &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="orgeaffcc2"></a>Size of Structs and Padding<br />
<div class="outline-text-5" id="text-20-2-1-6">
<ul class="org-ul">
<li>The size of a struct is <i>not</i> always the sum of sizes of its data members.</li>
<li>The compiler can add certain gaps (called padding) in the struct for performance reasons. For example, if the sum of size is 14 bytes, it will add gaps such that the size of the actual struct will be 16 bytes (2x8).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">size of this struct is 12</span>
<span class="org-keyword">struct</span> <span class="org-type">One</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">short</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">2 bytes of padding added to make the size 4 bytes</span>
  <span class="org-type">int</span> <span class="org-variable-name">b</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">short</span> <span class="org-variable-name">c</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">2 bytes of more padding added</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">size of this struct is 8</span>
<span class="org-keyword">struct</span> <span class="org-type">Two</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">b</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no padding</span>
  <span class="org-type">short</span> <span class="org-variable-name">c</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no padding</span>
  <span class="org-type">short</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no padding</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<blockquote>
<p>

</p>

<p>
Always define data members of structs in decreasing order of their size to avoid padding as much as possible.
</p>
</blockquote>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgc4e01bf" class="outline-4">
<h4 id="orgc4e01bf"><span class="section-number-4">20.2.2.</span> Class Templates on Structs</h4>
<div class="outline-text-4" id="text-20-2-2">
<ul class="org-ul">
<li>Just like function templates are used to generate function definitions, class templates are used to generate class types (structs, classes, etc).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">T</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">T</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">coords</span> <span class="org-rainbow-delimiters-depth-2">{</span>0,0<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; coords.x &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; coords.y &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>We can <b>not</b> overload structs for different data types. The compiler will see them just like a redefinition of the struct.</li>
<li>We can make functions for these template classes like this-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">T</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">T</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">T</span> <span class="org-function-name">getDistanceFromOrigin</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">pt</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::sqrt<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::pow<span class="org-rainbow-delimiters-depth-4">(</span>pt.x, 2<span class="org-rainbow-delimiters-depth-4">)</span> + <span class="org-constant">std</span>::pow<span class="org-rainbow-delimiters-depth-4">(</span>pt.y, 2<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span>2, 10<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">template argument will be deduced automatically</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getDistanceFromOrigin<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="org82171dc"></a><code>std::pair</code><br />
<div class="outline-text-5" id="text-20-2-2-1">
<ul class="org-ul">
<li>Working with pairs of data is very common.</li>
<li>The C++ standard library has a built-in class template for a pair type with <code>first</code> and <code>second</code> as the data members.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">utility</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">pair</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">{</span>2, 3.4<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; a.first &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; a.second &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Favour using this instead of writing your own "pair" class template.</li>
</ul>
</div>
</li>
<li><a id="org525a1e0"></a>CTAD (C++17)<br />
<div class="outline-text-5" id="text-20-2-2-2">
<ul class="org-ul">
<li>Class Template Argument Deduction</li>
<li>Starting from C++17, the compiler can deduce the types of template arguments on its own when instantiating objects of the class templates.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">T</span> <span class="org-variable-name">x</span>;
  <span class="org-type">T</span> <span class="org-variable-name">y</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Point</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span>1, 2<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>The above program won't work with C++17 but will work on C++20 because prior to C++20, you had to specify a "deduction guide" to the compiler so that it knows how to deduce the type.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">T</span> <span class="org-variable-name">x</span>;
  <span class="org-type">T</span> <span class="org-variable-name">y</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Deduction guide for C++17</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">We are simply saying that if it finds a declaration of Point with two arguments of type T and T</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">it should deduce the type to be of Pair&lt;T&gt;</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">Point</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span>, <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Point</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span>1, 2<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgd6ce347" class="outline-2">
<h2 id="orgd6ce347"><span class="section-number-2">21.</span> Object Oriented Programming</h2>
<div class="outline-text-2" id="text-21">
</div>
<div id="outline-container-orgdd33d85" class="outline-3">
<h3 id="orgdd33d85"><span class="section-number-3">21.1.</span> Classes</h3>
<div class="outline-text-3" id="text-21-1">
</div>
<div id="outline-container-orgf4d0bb3" class="outline-4">
<h4 id="orgf4d0bb3"><span class="section-number-4">21.1.1.</span> Introduction</h4>
<div class="outline-text-4" id="text-21-1-1">
<ul class="org-ul">
<li>A class is a program-defined type which can have member variables of different types and member functions.</li>
<li>Example definition of a class with member variables-</li>
<li>Structs and classes are almost identical in C++. Any example written using classes can also be written using structs and vice-versa.</li>
<li>Structs have all the capabilities that classes have in C++ (not in C though), so you may use the one you like or go with the convention of using classes.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">double</span> <span class="org-variable-name">wage</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0fbdaac" class="outline-4">
<h4 id="org0fbdaac"><span class="section-number-4">21.1.2.</span> Member Functions</h4>
<div class="outline-text-4" id="text-21-1-2">
<ul class="org-ul">
<li>Functions defined inside class types are called member functions.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Date</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">day</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">month</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">year</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; day &lt;&lt; <span class="org-string">'/'</span> &lt;&lt; month &lt;&lt; <span class="org-string">'/'</span> &lt;&lt; year &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Date</span> <span class="org-variable-name">today</span><span class="org-rainbow-delimiters-depth-2">{</span>23,3,2024<span class="org-rainbow-delimiters-depth-2">}</span>;
  today.print<span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Member functions can be written in any order in a class type.</li>
<li>Member functions can also be overloaded as long as they can be differentiated.</li>
<li>Defining members functions inside structs should be avoided because it makes them a non-agregate, and that's why we use classes instead.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-02-24 Sat 00:18</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
