<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-05 Tue 20:26 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>cpp-notes</title>
<meta name="author" content="Prayag Jain" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">cpp-notes</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org13baa8c">1. Compiler</a>
<ul>
<li><a href="#org2cbc9bd">1.1. Optimizations</a></li>
<li><a href="#org20f929a">1.2. Extensions</a></li>
<li><a href="#org82308ea">1.3. Enable Warnings</a></li>
<li><a href="#org8df1b7a">1.4. Version Code Names</a></li>
</ul>
</li>
<li><a href="#org4d086ae">2. Basics</a>
<ul>
<li><a href="#org7af4404">2.1. Statements</a></li>
<li><a href="#org97a7f23">2.2. Variable Assignment</a>
<ul>
<li><a href="#org9ee8498">2.2.1. The Maybe Unused Attribute</a></li>
</ul>
</li>
<li><a href="#org742c5d2">2.3. Implementation Defined Behavior</a></li>
<li><a href="#org7f697d3">2.4. Identifier Naming Conventions</a></li>
<li><a href="#org8e7bfce">2.5. Literals and Operators</a></li>
<li><a href="#org4b2a85d">2.6. Expressions</a></li>
</ul>
</li>
<li><a href="#org010184b">3. Functions and Files</a>
<ul>
<li><a href="#orgb3ececc">3.1. Return values</a></li>
<li><a href="#orgea788a3">3.2. Parameters and Arguments</a></li>
<li><a href="#org4b544ea">3.3. The One Definition Rule</a></li>
<li><a href="#orgc0c62b9">3.4. Namespaces</a></li>
<li><a href="#orgfc68fe9">3.5. Preprocessor</a>
<ul>
<li><a href="#orgf98c116">3.5.1. Preprocessor Directives</a></li>
<li><a href="#orgef6f5d6">3.5.2. Header Files</a></li>
<li><a href="#org7b93b3e">3.5.3. Header Guards</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb86e16a">4. Debugging</a>
<ul>
<li><a href="#orgcbe855d">4.1. Some Debugging Tactics</a></li>
<li><a href="#orge011be9">4.2. Using a debugger</a>
<ul>
<li><a href="#org8eb64bb">4.2.1. Step Into</a></li>
<li><a href="#orga2cead3">4.2.2. Step Over</a></li>
<li><a href="#org8dfbb58">4.2.3. Step Out</a></li>
<li><a href="#orgf260db6">4.2.4. Run to Cursor</a></li>
<li><a href="#orgf40a8ae">4.2.5. Continue</a></li>
<li><a href="#org1ef6cea">4.2.6. Breakpoints</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge54a06f">5. Data Types and Related Stuff</a>
<ul>
<li><a href="#orgbd722d7">5.1. Standard Integers</a></li>
<li><a href="#org63e1ff1">5.2. <code>size_t</code></a></li>
<li><a href="#orgb7c2691">5.3. Floating Point Precision</a></li>
<li><a href="#org7e6055f">5.4. Rounding Errors in Decimals</a></li>
<li><a href="#org8a7f94e">5.5. NaN and Infinity</a></li>
<li><a href="#org0f38e6b">5.6. Boolean Values</a></li>
<li><a href="#orgdb199d0">5.7. Explicit Type Conversions</a></li>
<li><a href="#orgfe7f805">5.8. Hexadecimal, Octal and Binary Literals</a></li>
</ul>
</li>
<li><a href="#orgd0d6fab">6. Constants and Strings</a>
<ul>
<li><a href="#orge0c524f">6.1. Constant Expressions</a></li>
<li><a href="#orgec57321">6.2. The Inline Keyword</a></li>
<li><a href="#org701c5aa">6.3. <code>constexpr</code> and <code>consteval</code></a></li>
<li><a href="#org06ccfbc">6.4. Immediate Functions</a></li>
<li><a href="#orgc8fff58">6.5. Strings</a></li>
<li><a href="#orge414273">6.6. <code>std::string_view</code></a></li>
</ul>
</li>
<li><a href="#org014b95c">7. Operators</a>
<ul>
<li><a href="#org55b59d7">7.1. Binary Division Operator</a></li>
<li><a href="#org8dff261">7.2. Comma Operator</a></li>
<li><a href="#org50e1889">7.3. Comparing floating points</a></li>
</ul>
</li>
<li><a href="#org5497404">8. Bit Manipulation</a>
<ul>
<li><a href="#orgc6ed3c0">8.1. Key Member Functions</a>
<ul>
<li><a href="#org4170941">8.1.1. <code>test(position)</code></a></li>
<li><a href="#org63abf82">8.1.2. <code>set(position)</code></a></li>
<li><a href="#orgd48f498">8.1.3. <code>reset(position)</code></a></li>
<li><a href="#orge48b6cf">8.1.4. <code>flip(position)</code></a></li>
<li><a href="#orge821176">8.1.5. <code>size()</code></a></li>
<li><a href="#org340e27e">8.1.6. <code>count()</code></a></li>
<li><a href="#orgf2e8ac5">8.1.7. <code>any()</code></a></li>
<li><a href="#org5859760">8.1.8. <code>none()</code></a></li>
<li><a href="#orgc5c2b09">8.1.9. <code>all()</code></a></li>
</ul>
</li>
<li><a href="#org36f24f8">8.2. Bitwise Operators</a></li>
<li><a href="#org61314cc">8.3. Bit Masks</a>
<ul>
<li><a href="#org25bd568">8.3.1. Testing Bits using Masks</a></li>
<li><a href="#org7077180">8.3.2. Setting and Resetting Bits using Masks</a></li>
</ul>
</li>
<li><a href="#org3306930">8.4. Example Hex Colour to RGBA Colour</a></li>
<li><a href="#orgf026bff">8.5. Two&rsquo;s Complement</a></li>
</ul>
</li>
<li><a href="#org7b2c95e">9. Namespaces</a>
<ul>
<li><a href="#org3e3921c">9.1. Namespace Aliases</a></li>
</ul>
</li>
<li><a href="#org9653ff2">10. Scope, Duration and Lifetime</a>
<ul>
<li><a href="#orgf22df79">10.1. Name Hiding (Shadowing)</a></li>
<li><a href="#org14c381c">10.2. Internal Linkage</a></li>
<li><a href="#orgc4a14fb">10.3. External Linkage</a></li>
<li><a href="#org5abfaf5">10.4. Non-constant Global Variables are Evil</a></li>
<li><a href="#org1646c76">10.5. Sharing Global Variables Across Files</a></li>
<li><a href="#orga79f6a6">10.6. Global Constants as Inline Variables</a></li>
<li><a href="#org9313988">10.7. Static on local variables</a></li>
<li><a href="#org1ff6707">10.8. Summary</a></li>
</ul>
</li>
<li><a href="#org4acc6fc">11. Using Declarations</a>
<ul>
<li><a href="#org938562e">11.1. Qualified and unqualified names</a></li>
<li><a href="#orgafb6791">11.2. Using-declarations</a></li>
<li><a href="#org38787bb">11.3. Using-directives</a></li>
</ul>
</li>
<li><a href="#orga582dc6">12. Control Flow</a>
<ul>
<li><a href="#org742e590">12.1. Null Statements</a></li>
<li><a href="#org64fc7c8">12.2. <code>constexpr</code> if statements</a></li>
<li><a href="#org836b770">12.3. The <code>[[fallthrough]]</code> attribute</a></li>
<li><a href="#org9340504">12.4. Halting Programs</a></li>
</ul>
</li>
<li><a href="#org2bdbc06">13. Randomness</a>
<ul>
<li><a href="#org17d966f">13.1. Built-in PRNGs in C++</a></li>
</ul>
</li>
<li><a href="#org1b76f0f">14. Software Testing</a>
<ul>
<li><a href="#orgf4fe441">14.1. Informal Testing</a></li>
<li><a href="#org8fa6a37">14.2. Code Coverage</a></li>
<li><a href="#org65c2633">14.3. Symantic Errors</a></li>
<li><a href="#org5b716ae">14.4. Detecting and Handling Errors</a></li>
<li><a href="#org105313f">14.5. Handling String Input</a>
<ul>
<li><a href="#org4a601d0">14.5.1. Error Case 1: Extraction succeeds but input is meaningless</a></li>
<li><a href="#org1a02944">14.5.2. Error Case 2: Input buffer already had some characters</a></li>
<li><a href="#org9c42c5e">14.5.3. Error Case 3: Extraction fails and program goes in an infinite loop</a></li>
</ul>
</li>
<li><a href="#org2497fca">14.6. Assertions</a>
<ul>
<li><a href="#org635f41f">14.6.1. Assert</a></li>
<li><a href="#org3a6fb02">14.6.2. Static Assert</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc7531d4">15. Type Conversions, Type Aliases, Type Deduction</a>
<ul>
<li><a href="#orgff4c0d1">15.1. Implicit Type Conversions</a>
<ul>
<li><a href="#org599012d">15.1.1. Numeric Promotions</a></li>
</ul>
</li>
<li><a href="#org4b32336">15.2. Narrowing Conversions</a></li>
<li><a href="#org47cd5ed">15.3. Type Aliases</a></li>
<li><a href="#orgb4c700a">15.4. Type Deduction</a></li>
</ul>
</li>
<li><a href="#orgd024e52">16. Function Overloading</a>
<ul>
<li><a href="#orgd7b9518">16.1. Function Overload Differentiation</a></li>
<li><a href="#orgbc0806a">16.2. Resolving Overloaded Function Calls</a></li>
<li><a href="#orgcfab2ee">16.3. Deleting Functions</a></li>
<li><a href="#orgfabd2f5">16.4. Default Arguments</a></li>
</ul>
</li>
<li><a href="#orgd5d76b2">17. Function Templates</a>
<ul>
<li><a href="#orgcd90fcc">17.1. Forward Declaring Function Templates</a></li>
<li><a href="#orgbebf446">17.2. Including Function Templates</a></li>
<li><a href="#org5a49bdb">17.3. Abbreviated Function Templates</a></li>
<li><a href="#org16d1f58">17.4. Non-type Template Parameters</a></li>
</ul>
</li>
<li><a href="#orgf47d43e">18. References</a>
<ul>
<li><a href="#orgac577f0">18.1. Lvalue and Rvalue Expressions</a></li>
<li><a href="#org544bd1b">18.2. Lvalue References</a></li>
<li><a href="#org1765341">18.3. Dangling References</a></li>
<li><a href="#org2520f6b">18.4. Lvalue references to const</a></li>
<li><a href="#orge1e3b2d">18.5. Pass Values by Reference To Functions</a>
<ul>
<li><a href="#org3dabb43">18.5.1. </a></li>
</ul>
</li>
<li><a href="#org4e8fd2e">18.6. Return by Reference</a></li>
<li><a href="#org143a901">18.7. In-Out Parameters</a></li>
</ul>
</li>
<li><a href="#orgb5608e3">19. Pointers</a>
<ul>
<li><a href="#org2b22caf">19.1. Dangling Pointers</a></li>
<li><a href="#org9e471d9">19.2. Null Pointers</a></li>
<li><a href="#orgd01bac3">19.3. Pointer to a Const</a></li>
<li><a href="#org942fdc4">19.4. Const Pointers</a></li>
<li><a href="#orge23bd6e">19.5. Const Pointer to a Const Variable</a></li>
<li><a href="#org08f71d3">19.6. Passing Values to Functions By Address</a></li>
<li><a href="#org5584fc4">19.7. Setting Optional Parameters in Functions</a></li>
<li><a href="#orgd432aba">19.8. Top Level and Low Level Consts</a></li>
<li><a href="#org6f1732a">19.9. Auto and Pointers</a>
<ul>
<li><a href="#orgf6acd4e">19.9.1. <span class="todo TODO">TODO</span> Read chapter 12.14 again!</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd3d706e">20. User Defined Types</a>
<ul>
<li><a href="#org495cfda">20.1. Enumeration Types</a>
<ul>
<li><a href="#orgd214acc">20.1.1. Unscoped Enumerations</a></li>
<li><a href="#org73f2aaa">20.1.2. Scoped Enumerations</a></li>
</ul>
</li>
<li><a href="#org42eb688">20.2. Class Types</a>
<ul>
<li><a href="#org15479c7">20.2.1. Structs</a></li>
<li><a href="#org17615f4">20.2.2. Class Templates on Structs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org69fed09">21. Object Oriented Programming</a>
<ul>
<li><a href="#org1a1cea4">21.1. Classes</a>
<ul>
<li><a href="#orgdbe380f">21.1.1. Introduction</a></li>
<li><a href="#orge46200f">21.1.2. Member Functions</a></li>
<li><a href="#org2b1a892">21.1.3. Const Class Type Objects</a></li>
<li><a href="#org8ea7b51">21.1.4. Access Levels</a></li>
<li><a href="#org1154789">21.1.5. Encapsulation (Data Hiding)</a></li>
<li><a href="#org0521d21">21.1.6. Constructors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org72c836a">22. More on Classes</a>
<ul>
<li><a href="#org2a84f49">22.1. The <code>this</code> keyword</a></li>
<li><a href="#orgea5e9c4">22.2. Returning <code>*this</code></a></li>
<li><a href="#orgf23a339">22.3. Resetting Class Objects</a></li>
<li><a href="#orgdd3e573">22.4. Classes and Header Files</a></li>
<li><a href="#org530f53c">22.5. Nested Types</a></li>
<li><a href="#org3272551">22.6. Destructors</a></li>
<li><a href="#org0f9b736">22.7. Class Templates with Member Functions</a></li>
<li><a href="#org19b2593">22.8. Static Members</a></li>
<li><a href="#org0b33c36">22.9. Static Member Functions</a></li>
<li><a href="#org9e5bac6">22.10. Friend Functions</a></li>
<li><a href="#org79ee19a">22.11. Friend Class</a></li>
<li><a href="#orgfeeaa43">22.12. Ref Qualifiers</a></li>
</ul>
</li>
<li><a href="#org42c9673">23. Vectors</a>
<ul>
<li><a href="#org17279a1">23.1. Constructing arrays of specific length</a></li>
<li><a href="#org30dcf19">23.2. <code>const</code> and <code>constexpr</code> vectors</a></li>
<li><a href="#org3b08061">23.3. Size of a vector</a></li>
<li><a href="#org6a2cd5c">23.4. Accessing elements of a vector</a></li>
<li><a href="#orgbae3d85">23.5. Passing Vectors</a></li>
<li><a href="#org487c571">23.6. Move Semantics</a></li>
<li><a href="#orgac7efbc">23.7. Range Based For Loop</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org13baa8c" class="outline-2">
<h2 id="org13baa8c"><span class="section-number-2">1.</span> Compiler</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org2cbc9bd" class="outline-3">
<h3 id="org2cbc9bd"><span class="section-number-3">1.1.</span> Optimizations</h3>
<div class="outline-text-3" id="text-1-1">
<p>
You can use the <code>-ggdb</code> flag to compile in debug mode and <code>-O2 -DNDEBUG</code> to compile with the best optimizations.
</p>
</div>
</div>
<div id="outline-container-org20f929a" class="outline-3">
<h3 id="org20f929a"><span class="section-number-3">1.2.</span> Extensions</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Disable compiler-specific extensions and strictly follow the C++ standard by adding the <code>-pedantic-errors</code> flag.
</p>
</div>
</div>
<div id="outline-container-org82308ea" class="outline-3">
<h3 id="org82308ea"><span class="section-number-3">1.3.</span> Enable Warnings</h3>
<div class="outline-text-3" id="text-1-3">
<p>
You should enable warnings for the best learning experience.
Enable them using- <code>-Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion</code>
To treat warnings as errors, add <code>-Werror</code> flag.
</p>
</div>
</div>
<div id="outline-container-org8df1b7a" class="outline-3">
<h3 id="org8df1b7a"><span class="section-number-3">1.4.</span> Version Code Names</h3>
<div class="outline-text-3" id="text-1-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Version</td>
<td class="org-left">Code Name Before Release</td>
</tr>

<tr>
<td class="org-left">C++11</td>
<td class="org-left">c++1x</td>
</tr>

<tr>
<td class="org-left">C++14</td>
<td class="org-left">c++1y</td>
</tr>

<tr>
<td class="org-left">C++17</td>
<td class="org-left">c++1z</td>
</tr>

<tr>
<td class="org-left">C++20</td>
<td class="org-left">c++2a</td>
</tr>

<tr>
<td class="org-left">C++23</td>
<td class="org-left">c++2b</td>
</tr>
</tbody>
</table>

<p>
Compiler flags are <code>-std=c++11</code>, <code>-std=c++14</code>, <code>-std=c++17</code>, <code>-std=c++20</code>, <code>-std=c++2b</code>
</p>
</div>
</div>
</div>
<div id="outline-container-org4d086ae" class="outline-2">
<h2 id="org4d086ae"><span class="section-number-2">2.</span> Basics</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org7af4404" class="outline-3">
<h3 id="org7af4404"><span class="section-number-3">2.1.</span> Statements</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A statement is an instruction in a computer program that tells the computer to perform an action.
</p>
<ol class="org-ol">
<li>Declaration Statements</li>
<li>Jump Statements</li>
<li>Expression Statements</li>
<li>Compound Statements</li>
<li>Selection Statements (Conditionals)</li>
<li>Iteration Statements</li>
<li>Try Blocks</li>
</ol>
</div>
</div>
<div id="outline-container-org97a7f23" class="outline-3">
<h3 id="org97a7f23"><span class="section-number-3">2.2.</span> Variable Assignment</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>Assignment
When variables are assigned using the <code>=</code> operator, value on the right hand side is copied to the variable on the left hand side, known as <i>copy assignment</i>.</li>
<li>Initialization
<ol class="org-ol">
<li>Default Initialization
No initial value is provided.</li>
<li>Copy Initialization
Initializer is provided after equal sign.
Use of this is discouraged because it is considered inefficient.
<code>int a = 5;</code></li>
<li>Direct Initialization
Initializer is provided inside parenthesis.
Use of this is also discouraged, because it is confusing to read and is superseded by list initialization.
<code>int a(5);</code></li>
<li><p>
List Initialization
Modern way. It does not allow narrow conversions because narrow conversions can cause data loss. Introduced in C++17.
</p>
<div class="org-src-container">
<pre class="src src-C++">      <span class="org-type">int</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">direct list initialization</span>
      <span class="org-type">int</span> <span class="org-variable-name">a</span> = <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">copy list initialization</span>
      <span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">value list initialization</span>
      <span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">4.5</span><span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">ERROR while a(4.5) or a = 4.5 won't give any error</span>
</pre>
</div></li>
</ol></li>
</ol>
</div>
<div id="outline-container-org9ee8498" class="outline-4">
<h4 id="org9ee8498"><span class="section-number-4">2.2.1.</span> The Maybe Unused Attribute</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
If we don&rsquo;t want the compiler to complain about unused variables, we can define variables with <code>[[maybe_unused]]</code>.
This was introduced in C++17.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-type">float</span> <span class="org-variable-name">pi</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">3.14</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org742c5d2" class="outline-3">
<h3 id="org742c5d2"><span class="section-number-3">2.3.</span> Implementation Defined Behavior</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Implementation-defined behavior means the behavior of some syntax is left up to the implementation (the compiler) to define. Such behaviors must be consistent and documented, but different compilers may produce different results.
One example of this is using the <code>sizeof</code> operator. It will product different results on different platforms.
</p>
</div>
</div>
<div id="outline-container-org7f697d3" class="outline-3">
<h3 id="org7f697d3"><span class="section-number-3">2.4.</span> Identifier Naming Conventions</h3>
<div class="outline-text-3" id="text-2-4">
<ol class="org-ol">
<li>Variable names should begin with lowercase characters.</li>
<li>Function names should begin with lowercase characters.</li>
<li>Identifier names starting with capital letters represent user defined types.</li>
<li><code>camelCase</code> or <code>snake_case</code> both are fine but stay consistent.</li>
<li>You may mix them like <code>snake_case</code> for variable names and <code>camelCase</code> for function names.</li>
<li>Do not start names with underscore <code>_</code> (bad practice but not impossible).</li>
</ol>
</div>
</div>
<div id="outline-container-org8e7bfce" class="outline-3">
<h3 id="org8e7bfce"><span class="section-number-3">2.5.</span> Literals and Operators</h3>
<div class="outline-text-3" id="text-2-5">
<p>
A literal is a constant value inserted directly in the source code.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">a</span> = <span class="org-highlight-numbers-number">5</span>;
<span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-constant">std</span>::endl;  <span class="org-comment-delimiter">// </span><span class="org-comment">a is a variable not a literal constant</span>
<span class="org-constant">std</span>::cout &lt;&lt; <span class="org-highlight-numbers-number">10</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">10 is a literal constant</span>
</pre>
</div>

<p>
Operators perform operations on its inputs and return an output.
The number of inputs an operator can take is called its <b>arity</b>.
Some operators like <code>throw</code> and <code>delete</code> do not return any value.
Operators which are mainly used for their side effects like <code>x = 5</code> always return their left operand (<code>x</code> in this case).
For example, <code>x = y = 5</code> is the same as writing <code>x = (y = 5)</code>.
</p>
</div>
</div>
<div id="outline-container-org4b2a85d" class="outline-3">
<h3 id="org4b2a85d"><span class="section-number-3">2.6.</span> Expressions</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Expressions are like phrases in English, they are part of statements just like phrases are part of sentences.
Expressions do not end with a semi-colon and they cannot be executed themselves.
Some examples of expressions-
</p>
<div class="org-src-container">
<pre class="src src-C++">a = <span class="org-highlight-numbers-number">5</span>              <span class="org-comment-delimiter">// </span><span class="org-comment">has a side-effect of assigning "a" to 5 and evaluates to "a"</span>
<span class="org-highlight-numbers-number">5</span> + <span class="org-highlight-numbers-number">6</span>              <span class="org-comment-delimiter">// </span><span class="org-comment">evaluates to 11</span>
<span class="org-string">"Hello, World!"</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">evaluates to itself</span>
<span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Hey"</span> <span class="org-comment-delimiter">// </span><span class="org-comment">evaluates to std::cout</span>
</pre>
</div>
<p>
Ending an expression with a semi-colon <code>;</code> will cause the statement to execute properly and such expressions are called <b>Expression Statements</b>.
Sub-expressions are expressions used as operands in other expressions.
Compound expressions have two or more operators like <code>x = 5 + 3</code> has two operators, <code>=</code> and <code>+</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-org010184b" class="outline-2">
<h2 id="org010184b"><span class="section-number-2">3.</span> Functions and Files</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgb3ececc" class="outline-3">
<h3 id="orgb3ececc"><span class="section-number-3">3.1.</span> Return values</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The main function can return integers to specify if the program ran successfully or not.
Two macros, <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> are defined in the <code>cstdlib</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdlib</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-constant">EXIT_SUCCESS</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<p>
A value defining function which does not return any value will produce undefined results.
</p>
</div>
</div>
<div id="outline-container-orgea788a3" class="outline-3">
<h3 id="orgea788a3"><span class="section-number-3">3.2.</span> Parameters and Arguments</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>Parameters are defined in the function header and arguments are passed when calling it.</li>
<li><p>
If you have a parameter that is no longer used in the body but can&rsquo;t remove the corresponding argument from all function calls, you can just remove the identifier-
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-type">void</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-comment-delimiter">/*</span><span class="org-comment">name</span><span class="org-comment-delimiter">*/</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">indentifier removed from parameter list</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">to avoid breaking previous function calls</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">and prevent unused parameter warning</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<blockquote>
<p>

</p>

<p>
IMPORTANT!
Note that in clang, arguments are parsed from left to right while in g++, arguments are parsed from right to left!
</p>
</blockquote></li>
</ul>
</div>
</div>
<div id="outline-container-org4b544ea" class="outline-3">
<h3 id="org4b544ea"><span class="section-number-3">3.3.</span> The One Definition Rule</h3>
<div class="outline-text-3" id="text-3-3">
<ol class="org-ol">
<li>Within a file, each function, variable, type or template can only have one definition (except variables in different local scopes) (violation causes compile error)</li>
<li>With a program (multiple files), each variable can have only one definition (violation causes linker error)</li>
<li>Types, templates, inline functions, and inline variables are allowed to have duplicate definitions in different files, so long as each definition is identical (violation causes undefined behaviour).</li>
</ol>
</div>
</div>
<div id="outline-container-orgc0c62b9" class="outline-3">
<h3 id="orgc0c62b9"><span class="section-number-3">3.4.</span> Namespaces</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>A namespace provides a scope region called the namespace scope which means that any thing defined in that scope won&rsquo;t be mistaken for anything else with the same name defined in some other namespace.</li>
<li>Only declarations and definitions can appear in a namespace.</li>
<li>The <code>::</code> operator is called the <b>scope resolution operator</b>. It&rsquo;s left operand is the namespace name (if blank, global is used) and the right operator is the symbol.</li>
<li>When an identifier uses the <code>::</code> operator, it&rsquo;s called a qualified name.</li>
<li>Using <code>using namespace &lt;name&gt;</code> is considered bad practice since it can lead to many conflicts in the future.</li>
</ul>
</div>
</div>
<div id="outline-container-orgfc68fe9" class="outline-3">
<h3 id="orgfc68fe9"><span class="section-number-3">3.5.</span> Preprocessor</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>A preprocessor is a <i>program</i> which makes various changes to the code file before compiling it. For example, stripping out comments, making sure the each file ends with a newline character etc, evaluating the <b>preprocessor directives</b>, etc..</li>
<li>It does not make changes to the original files, instead it creates temporary files for this called &ldquo;translation units&rdquo;.</li>
<li>The translation unit is what is actually compiled by the compiler.</li>
</ul>
</div>
<div id="outline-container-orgf98c116" class="outline-4">
<h4 id="orgf98c116"><span class="section-number-4">3.5.1.</span> Preprocessor Directives</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>These are statements that begin with a <code>#</code> and end with a newline.</li>
<li>They have their own syntax of doing things.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org3d683b4"></a>Include Directive<br />
<div class="outline-text-5" id="text-3-5-1-1">
<p>
Includes header files - <code>#include &lt;iostream&gt;</code>
</p>
</div>
</li>
<li><a id="orga87f303"></a>Define Directive<br />
<div class="outline-text-5" id="text-3-5-1-2">
<ul class="org-ul">
<li>Used to define function macros or object macros.</li>
<li>Function macros are not considered unsafe.</li>
<li><p>
Object-like macros are no longer used in favour of better alternatives.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Replace all occurance of NOTHING with nothing</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">NOTHING</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Replace all occurances of PI with 3.14</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">PI</span> <span class="org-highlight-numbers-number">3.14</span>
</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="org1468747"></a>Conditional Directives<br />
<div class="outline-text-5" id="text-3-5-1-3">
<p>
This includes the <code>ifdef</code>, <code>ifndef</code> and <code>endif</code> directives.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgef6f5d6" class="outline-4">
<h4 id="orgef6f5d6"><span class="section-number-4">3.5.2.</span> Header Files</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>Header files must not contain definitions.</li>
<li>It is a good practice for code files to #include their paired header file (if one exists), this will help the compiler catch errors at compile time instead of link time.</li>
<li>Many useful C libraries are now renamed in C++, for example, <code>stdlib.h</code> is named <code>cstdlib</code> in C++.</li>
<li>The <i>bad</i> way to include header files is to use relative paths in the <code>#include</code> directive. For example, <code>#include "../myfile.h"</code>.</li>
<li>The better way is to specify the <code>include directory</code> to the compiler using the <code>-I</code> flag- <code>g++ main.cpp -I/src/includes -o main</code>. There is no space after <code>-I</code> in the command.</li>
</ul>
</div>
</div>
<div id="outline-container-org7b93b3e" class="outline-4">
<h4 id="org7b93b3e"><span class="section-number-4">3.5.3.</span> Header Guards</h4>
<div class="outline-text-4" id="text-3-5-3">
<p>
Used to prevent duplication definitions when including multiple header files.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> <span class="org-constant">FUNCTIONS_H</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">FUNCIONS_H</span>
<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-function-name">...</span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-preprocessor">#endif</span>
</pre>
</div>

<ul class="org-ul">
<li>You can also use <code>#pragma once</code> in modern compilers instead of the above header guards, but it&rsquo;s not in the C++ standard and some compilers may not support it.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb86e16a" class="outline-2">
<h2 id="orgb86e16a"><span class="section-number-2">4.</span> Debugging</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgcbe855d" class="outline-3">
<h3 id="orgcbe855d"><span class="section-number-3">4.1.</span> Some Debugging Tactics</h3>
<div class="outline-text-3" id="text-4-1">
<ol class="org-ol">
<li>Comment out code</li>
<li>Use <code>std::cerr</code> instead of <code>std::cout</code> because <code>std::cerr</code> is unbuffered so output is instant.</li>
<li>Printing values.</li>
</ol>
<p>
Using debug statements isn&rsquo;t recommended since they can clutter your code.
</p>
</div>
</div>
<div id="outline-container-orge011be9" class="outline-3">
<h3 id="orge011be9"><span class="section-number-3">4.2.</span> Using a debugger</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org8eb64bb" class="outline-4">
<h4 id="org8eb64bb"><span class="section-number-4">4.2.1.</span> Step Into</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Execute the next command and pause.
If the next command is a function call, move to the top of the function.
</p>
</div>
</div>
<div id="outline-container-orga2cead3" class="outline-4">
<h4 id="orga2cead3"><span class="section-number-4">4.2.2.</span> Step Over</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
Execute the next command and pause.
If the next command is a function call, execute the entire function at once.
</p>
</div>
</div>
<div id="outline-container-org8dfbb58" class="outline-4">
<h4 id="org8dfbb58"><span class="section-number-4">4.2.3.</span> Step Out</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
Execute all remaining lines in the current function and pause.
</p>
</div>
</div>
<div id="outline-container-orgf260db6" class="outline-4">
<h4 id="orgf260db6"><span class="section-number-4">4.2.4.</span> Run to Cursor</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
Execute the program upto the line the cursor is in and pause.
</p>
</div>
</div>
<div id="outline-container-orgf40a8ae" class="outline-4">
<h4 id="orgf40a8ae"><span class="section-number-4">4.2.5.</span> Continue</h4>
<div class="outline-text-4" id="text-4-2-5">
<p>
Continue running the program normally.
</p>
</div>
</div>
<div id="outline-container-org1ef6cea" class="outline-4">
<h4 id="org1ef6cea"><span class="section-number-4">4.2.6.</span> Breakpoints</h4>
<div class="outline-text-4" id="text-4-2-6">
<p>
Execute the program upto the breakpoint and pause.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge54a06f" class="outline-2">
<h2 id="orge54a06f"><span class="section-number-2">5.</span> Data Types and Related Stuff</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgbd722d7" class="outline-3">
<h3 id="orgbd722d7"><span class="section-number-3">5.1.</span> Standard Integers</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Since the size of <code>int</code> is different on different compilers on different platforms, standard int was declared in the <code>cstdint</code> library.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">std::int8_t</span> <span class="org-variable-name">one</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">1 byte integer</span>
  <span class="org-type">std::uint8_t</span> <span class="org-variable-name">two</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">1 byte unsigned integer</span>
  <span class="org-type">std::int16_t</span> <span class="org-variable-name">three</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">2 byte integer</span>
  <span class="org-type">std::uint16_t</span> <span class="org-variable-name">four</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">2 byte unsigned integer</span>
  <span class="org-type">std::int32_t</span> <span class="org-variable-name">five</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">4 byte integer</span>
  <span class="org-type">std::uint32_t</span> <span class="org-variable-name">six</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">4 byte unsigned integer</span>
  <span class="org-type">std::int64_t</span> <span class="org-variable-name">seven</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">8 byte integer</span>
  <span class="org-type">std::uint64_t</span> <span class="org-variable-name">eight</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">8 byte unsigned integer</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The above may be slower on some hardware. For example, 32 bit integers may be slower than 64 bit integers on a 64bit CPU so the following types were created:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">std::int_fast32_t</span> <span class="org-variable-name">a</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will give the fastest integer having atleast 32 bits</span>
  <span class="org-type">std::int_least32_t</span> <span class="org-variable-name">b</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will give the smallest integer having atleast 32 bits</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<blockquote>
<p>

</p>

<p>
Note that in many compilers, <code>int_fast8_t</code> and <code>int_least8_t</code> behave like <code>char</code> instead of integer values so prefer using the 16bit versions. So, if you try to print a variable of type <code>int_fast8_t</code> with the value 65 (for example), it will print A instead!!
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org63e1ff1" class="outline-3">
<h3 id="org63e1ff1"><span class="section-number-3">5.2.</span> <code>size_t</code></h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>This type is used to represent size or length of objects.</li>
<li>The data type of the value returned by the <code>sizeof</code> operator is also <code>std::size_t</code>.</li>
<li>It is guaranteed to be unsigned and has the size of the largest possible integer the machine can hold.</li>
<li>Any object with a size larger than the largest value an object of type <code>std::size_t</code> can hold is considered ill-formed.</li>
</ul>
</div>
</div>
<div id="outline-container-orgb7c2691" class="outline-3">
<h3 id="orgb7c2691"><span class="section-number-3">5.3.</span> Floating Point Precision</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>By default, <code>std::cout</code> displays only upto 6 significant digits of floating point numbers. You can change the precision by using <code>std::cout &lt;&lt; std::setprecision(&lt;any number&gt;)</code>.</li>
<li>Prefer <code>double</code> over <code>float</code> for better precision.</li>
</ul>
</div>
</div>
<div id="outline-container-org7e6055f" class="outline-3">
<h3 id="org7e6055f"><span class="section-number-3">5.4.</span> Rounding Errors in Decimals</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li><p>
In binary, a simple decimal number like 0.1 is represented in an infinite sequence 0.00011001100&#x2026; causing it to be less precise.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

  <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">double</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">0.1</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">20</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    b = <span class="org-highlight-numbers-number">0.1</span> + <span class="org-highlight-numbers-number">0.1</span> + <span class="org-highlight-numbers-number">0.1</span> + <span class="org-highlight-numbers-number">0.1</span> + <span class="org-highlight-numbers-number">0.1</span> + <span class="org-highlight-numbers-number">0.1</span> + <span class="org-highlight-numbers-number">0.1</span> + <span class="org-highlight-numbers-number">0.1</span> + <span class="org-highlight-numbers-number">0.1</span> + <span class="org-highlight-numbers-number">0.1</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">should be equal to 1.0</span>
    <span class="org-constant">std</span>::cout &lt;&lt; b &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>a == b<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"YES"</span>;
    <span class="org-keyword">else</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"NO"</span>;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org8a7f94e" class="outline-3">
<h3 id="org8a7f94e"><span class="section-number-3">5.5.</span> NaN and Infinity</h3>
<div class="outline-text-3" id="text-5-5">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">double</span> <span class="org-variable-name">zero</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">0.0</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-highlight-numbers-number">5.0</span>/zero &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">outputs inf</span>
  <span class="org-constant">std</span>::cout &lt;&lt; zero/zero &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">outputs nan</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0f38e6b" class="outline-3">
<h3 id="org0f38e6b"><span class="section-number-3">5.6.</span> Boolean Values</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>No need to import <code>stdbool</code> like in C to use <code>true</code> and <code>false</code>.</li>
<li>Sending <code>true</code> and <code>false</code> values to stdout prints 0 and 1 instead.</li>
<li><p>
To print true and false instead, do this-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

  <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">bool</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">b</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-negation-char">!</span>a<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-string">" "</span> &lt;&lt; b &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha; <span class="org-comment-delimiter">// </span><span class="org-comment">causes bools to print as "true" or "false"</span>
    <span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-string">" "</span> &lt;&lt; b &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgdb199d0" class="outline-3">
<h3 id="orgdb199d0"><span class="section-number-3">5.7.</span> Explicit Type Conversions</h3>
<div class="outline-text-3" id="text-5-7">
<ul class="org-ul">
<li><p>
Unlike C, where we convert types using <code>(&lt;type&gt;) variable</code> to cast to different types, in C++, we use <code>static_cast</code> operator.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-1">}</span>

  <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>a<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>
  
The <code>static_cast</code> operator will produce undefined behavior if the value being converted doesnt fit in range of the new type.
</p>
</blockquote></li>
</ul>
</div>
</div>
<div id="outline-container-orgfe7f805" class="outline-3">
<h3 id="orgfe7f805"><span class="section-number-3">5.8.</span> Hexadecimal, Octal and Binary Literals</h3>
<div class="outline-text-3" id="text-5-8">
<p>
You may use these decimals by prefixing the following-
</p>
<ul class="org-ul">
<li><code>0x</code> for hexadecimal, eg- <code>int a{0x1F}</code></li>
<li><code>0</code> for octal, eg- <code>int a{012}</code></li>
<li><code>0b</code> for binary, eg- <code>int a{0b1100011}</code> (c++14 onwards)</li>
</ul>
<p>
By default, <code>std::cout</code> outputs values in decimals.
You can specify the output type using-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">bitset</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">for std::bitset</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">69420</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Decimal</span>
  <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Octal</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::oct;
  <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Hexadecimal</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::hex;
  <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Binary</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::<span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-highlight-numbers-number">16</span><span class="org-rainbow-delimiters-depth-2">&gt;{</span><span class="org-keyword">0b</span><span class="org-constant">10110</span><span class="org-rainbow-delimiters-depth-2">}</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
In C++20 and C++23, better options are available-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">format</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">C++20</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">#include &lt;print&gt; // C++23</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::format<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"{:b}\n"</span>, <span class="org-keyword">0b</span><span class="org-constant">1100101</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::format<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"{:#b}\n"</span>, <span class="org-keyword">0b</span><span class="org-constant">1100101</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">std::print("{:#b}\n", 0b1100101); C++23</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd0d6fab" class="outline-2">
<h2 id="orgd0d6fab"><span class="section-number-2">6.</span> Constants and Strings</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orge0c524f" class="outline-3">
<h3 id="orge0c524f"><span class="section-number-3">6.1.</span> Constant Expressions</h3>
<div class="outline-text-3" id="text-6-1">
<p>
An expression that contains only compile time constants.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">a</span> = <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-highlight-numbers-number">5</span> + <span class="org-highlight-numbers-number">7</span> <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Will be evaluated at compile-time</span>
<span class="org-type">int</span> <span class="org-variable-name">a</span> = <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-highlight-numbers-number">5</span> + <span class="org-highlight-numbers-number">7</span> <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Might be evaluated at runtime, depends on the compiler</span>
</pre>
</div>

<p>
Using <code>const</code> can let the compiler know that the variable will absolutely <i>not</i> change whatsoever, so it can optimize it!
</p>

<blockquote>
<p>

</p>

<p>
Only const <i>integral</i> variables with a constant expression initializer are compile-time constants.
So, doubles or floats do not count.
Types like char, bool, int, long, unsigned long etc can be considered.
</p>
</blockquote>

<ul class="org-ul">
<li>It is sometimes very hard to distinguish whether an expression evaluates to a compile-time constant or not, so we can use <code>constexpr</code> keyword to tell the compiler that it&rsquo;s a compile time constant (using <code>const</code> doesn&rsquo;t guarantee it because it just means that the variable&rsquo;s value cannot be changed).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-highlight-numbers-number">5</span> + <span class="org-highlight-numbers-number">7</span> <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Will be evaluated at compile-time instead of run-time</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgec57321" class="outline-3">
<h3 id="orgec57321"><span class="section-number-3">6.2.</span> The Inline Keyword</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>Every function call has a cost. Whenever a function call is made, the CPU has to save the current state of the program, jump to the function, execute it, and then jump back to the original location and restore the state. This is called function call overhead.</li>
<li>Inline functions are functions whose definition is expanded in-place instead of being called. This reduces the function call overhead.</li>
<li>The <code>inline</code> keyword just suggests the compiler to make the function inline, it is not guaranteed to do so.</li>
<li>Inline functions perform better when they are small and are called frequently.</li>
<li>Inline functions are <b>allowed</b> to be defined in multiple translation units in modern C++!</li>
<li>Every inline definition must be identical and are mostly defined in header files.</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-function-name">is_even</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> x % <span class="org-highlight-numbers-number">2</span> == <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org701c5aa" class="outline-3">
<h3 id="org701c5aa"><span class="section-number-3">6.3.</span> <code>constexpr</code> and <code>consteval</code></h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>As stated above, <code>constexpr</code> is used to tell the compiler that a variable is a compile-time constant.</li>
<li><p>
<code>constexpr</code> can be used with functions to tell the compiler that the function is a compile-time function.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-function-name">greater</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>x &gt; y ? x : y<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>If the parameters passed to a <code>constexpr</code> function are not compile-time constants, the function will be evaluated at run-time.</li>
<li>If the return value is not being used in a context where a compile-time constant is required, the function may or may not be evaluated at run-time.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">for std::is_constant_evaluated</span>

<span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-function-name">greater</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>x &gt; y ? x : y<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">p</span> <span class="org-rainbow-delimiters-depth-2">{</span>greater<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-highlight-numbers-number">5</span>, <span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">always a compile time constant</span>
  <span class="org-constant">std</span>::cout &lt;&lt; p &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-constant">std</span>::cout &lt;&lt; greater<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">5</span>, <span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">may be a compile time constant</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org06ccfbc" class="outline-3">
<h3 id="org06ccfbc"><span class="section-number-3">6.4.</span> Immediate Functions</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>We can force functions which <i>will</i> be used in a context where a compile-time constant is required to be evaluated at compile-time using the <code>consteval</code> keyword.</li>
<li>Only available in C++20.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">consteval</span> <span class="org-type">bool</span> <span class="org-function-name">getbigger</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>a &gt; b ? a : b<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">{</span>getbigger<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-highlight-numbers-number">5</span>, <span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; a &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">ok</span>

  <span class="org-constant">std</span>::cout &lt;&lt; getbigger<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">5</span>, <span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">ok</span>

  <span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">not constexpr</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getbigger<span class="org-rainbow-delimiters-depth-2">(</span>x, <span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">error</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>These functions are compile-time functions so they aren&rsquo;t very flexible during run-time.</li>
<li><code>consteval</code> and <code>constexpr</code> functions are implicitly <code>inline</code> because the compiler needs to see the full definition at all times where the function is called.</li>
</ul>
</div>
</div>
<div id="outline-container-orgc8fff58" class="outline-3">
<h3 id="orgc8fff58"><span class="section-number-3">6.5.</span> Strings</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>C like strings are avoided because they are hard to work with and can be unsafe.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Prayag"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  name = <span class="org-string">"Prayag Jain"</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">can be reassigned</span>
  <span class="org-constant">std</span>::cout &lt;&lt; name &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>You can use <code>std::getline()</code> to read strings in C++.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">str</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Enter name: "</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">std::cin &gt;&gt; std::ws is an expression which ultimately returns std::cin</span>
  <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin &gt;&gt; <span class="org-constant">std</span>::ws, str<span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Hi there, "</span> &lt;&lt; str &lt;&lt; <span class="org-string">"!"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li><code>std::ws</code> is an input manipulator which allows getline to ignore any leading whitespace characters already present in the input buffer.</li>
<li><code>std::ws</code> is not preserved across calls so it must be used with every getline call.</li>
<li>Use <code>str.length()</code> or <code>std::ssize(str)</code> (defined in <code>&lt;string&gt;</code>) to get the length of a string named <code>str</code>.</li>
<li>Initializing using <code>std::string</code> is expensive, so do not pass them by value in functions.</li>
<li>Normal string literals with double quotes around them are C-Style string literals, E.g. <code>"hello"</code>.</li>
<li>Using the suffix <code>std::string_literals::s</code> will form an <code>std::string</code> literal, E.g. <code>"hello"std::string_literals::s</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-orge414273" class="outline-3">
<h3 id="orge414273"><span class="section-number-3">6.6.</span> <code>std::string_view</code></h3>
<div class="outline-text-3" id="text-6-6">
<ul class="org-ul">
<li>Whenever an <code>std:string</code> is initialized, the string literal provided is copied into the string object (expensive operation).</li>
<li>Even in functions, when an <code>std::string</code> is passed by value, it is copied into the function parameter (expensive operation).</li>
<li><code>std::string_view</code> is a lightweight alternative to <code>std::string</code>.</li>
<li>Always prefer <code>std::string_view</code> over <code>std::string</code> unless you need to modify the string.</li>
<li>It lives under the <code>&lt;string_view&gt;</code> header.</li>
<li>Assigning a new string to a <code>std::string_view</code> will not change the original string, it will just point to the new string.</li>
<li>You can use the <code>std::string_view_literals::sv</code> suffix to form a <code>std::string_view</code> literal.</li>
<li>Unlike <code>std::string</code>, <code>std::string_view</code> can be used in <code>constexpr</code> contexts.</li>
<li>The <code>remove_prefix(count)</code> and <code>remove_suffix(count)</code> member functions can be used to remove a prefix or suffix from a string view (does NOT modify the referenced string, just the view).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string_view</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">str</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Hello, World!"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; str &lt;&lt; <span class="org-constant">std</span>::endl;;

  str.remove_prefix<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">remove the first two characters</span>
  str.remove_suffix<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">remove the last two characters</span>
  <span class="org-constant">std</span>::cout &lt;&lt; str &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org014b95c" class="outline-2">
<h2 id="org014b95c"><span class="section-number-2">7.</span> Operators</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org55b59d7" class="outline-3">
<h3 id="org55b59d7"><span class="section-number-3">7.1.</span> Binary Division Operator</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>It&rsquo;s the <code>/</code> operator we use to divide its two operands.</li>
<li>If one of the operands is a float, the operator performs floating point division.</li>
<li>If both operands are integers, the operator performs integer division and removes the fractional part.</li>
<li>If we want to divide two integers and get a float, we can use the <code>static_cast&lt;type&gt;</code> operator to cast one of the operands to a float/double.</li>
</ul>
</div>
</div>
<div id="outline-container-org8dff261" class="outline-3">
<h3 id="org8dff261"><span class="section-number-3">7.2.</span> Comma Operator</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li><code>x,y</code> means first evaluate x, then evaluate y and finally return the value of y</li>
</ul>
</div>
</div>
<div id="outline-container-org50e1889" class="outline-3">
<h3 id="org50e1889"><span class="section-number-3">7.3.</span> Comparing floating points</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>Floating points are dangerous to compare using the traditional comparison operators like <code>==</code>, <code>&lt;</code> and <code>&gt;</code> because of rounding errors.</li>
<li>Use the nearly equal algorithm which makes use of relative epsilons to check if two floating points are nearly equal.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5497404" class="outline-2">
<h2 id="org5497404"><span class="section-number-2">8.</span> Bit Manipulation</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>We can use individual bits in a byte to store boolean values or values that only depend on one bit.</li>
<li>When individual bits of an object are used as boolean values, we call them <b>bit flags</b>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">bitset</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-highlight-numbers-number">8</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">mybitset</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>We reading bits, we number them from right to left (starting from 0).</li>
</ul>
</div>
<div id="outline-container-orgc6ed3c0" class="outline-3">
<h3 id="orgc6ed3c0"><span class="section-number-3">8.1.</span> Key Member Functions</h3>
<div class="outline-text-3" id="text-8-1">
</div>
<div id="outline-container-org4170941" class="outline-4">
<h4 id="org4170941"><span class="section-number-4">8.1.1.</span> <code>test(position)</code></h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
Used to test whether a bit is 0 or 1
</p>
</div>
</div>
<div id="outline-container-org63abf82" class="outline-4">
<h4 id="org63abf82"><span class="section-number-4">8.1.2.</span> <code>set(position)</code></h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
Used to turn a bit &ldquo;on&rdquo; (to 1).
</p>
</div>
</div>
<div id="outline-container-orgd48f498" class="outline-4">
<h4 id="orgd48f498"><span class="section-number-4">8.1.3.</span> <code>reset(position)</code></h4>
<div class="outline-text-4" id="text-8-1-3">
<p>
Used to turn a bit &ldquo;off&rdquo; (to 0).
</p>
</div>
</div>
<div id="outline-container-orge48b6cf" class="outline-4">
<h4 id="orge48b6cf"><span class="section-number-4">8.1.4.</span> <code>flip(position)</code></h4>
<div class="outline-text-4" id="text-8-1-4">
<p>
Used to flip a bit (to 1 if it was 0 and to 0 if it was 1).
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">bitset</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">bitset</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">bits</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">10101</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; bits &lt;&lt; <span class="org-string">'\n'</span>;

  bits.set<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; bits &lt;&lt; <span class="org-string">'\n'</span>;

  bits.flip<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; bits &lt;&lt; <span class="org-string">'\n'</span>;

  bits.reset<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; bits &lt;&lt; <span class="org-string">'\n'</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orge821176" class="outline-4">
<h4 id="orge821176"><span class="section-number-4">8.1.5.</span> <code>size()</code></h4>
<div class="outline-text-4" id="text-8-1-5">
<p>
Returns the number of bits in the bitset.
</p>
</div>
</div>
<div id="outline-container-org340e27e" class="outline-4">
<h4 id="org340e27e"><span class="section-number-4">8.1.6.</span> <code>count()</code></h4>
<div class="outline-text-4" id="text-8-1-6">
<p>
Returns the number of bits set to 1.
</p>
</div>
</div>
<div id="outline-container-orgf2e8ac5" class="outline-4">
<h4 id="orgf2e8ac5"><span class="section-number-4">8.1.7.</span> <code>any()</code></h4>
<div class="outline-text-4" id="text-8-1-7">
<p>
Returns true if any bit is set to 1.
</p>
</div>
</div>
<div id="outline-container-org5859760" class="outline-4">
<h4 id="org5859760"><span class="section-number-4">8.1.8.</span> <code>none()</code></h4>
<div class="outline-text-4" id="text-8-1-8">
<p>
Returns true if none of the bits are set to 1.
</p>
</div>
</div>
<div id="outline-container-orgc5c2b09" class="outline-4">
<h4 id="orgc5c2b09"><span class="section-number-4">8.1.9.</span> <code>all()</code></h4>
<div class="outline-text-4" id="text-8-1-9">
<p>
Returns true if all of the bits are set to 1.
</p>
</div>
</div>
</div>
<div id="outline-container-org36f24f8" class="outline-3">
<h3 id="org36f24f8"><span class="section-number-3">8.2.</span> Bitwise Operators</h3>
<div class="outline-text-3" id="text-8-2">
<ol class="org-ol">
<li><code>&gt;&gt;</code> (right shift) (eg- 0011 &gt;&gt; 1 = 0001, 0011 &gt;&gt; 2 = 0000)</li>
<li><code>&lt;&lt;</code> (left shift) (eg- 0011 &lt;&lt; 1 = 0110, 0011 &lt;&lt; 2 = 1100)</li>
<li><code>&amp;</code> (bitwise and) (eg- 0101 &amp; 0011 = 0001)</li>
<li><code>|</code> (bitwise or) (eg- 0101 | 0011 = 0111) (only one bit should be 1 to be evaluated as true)</li>
<li><code>^</code> (bitwise xor) (eg- 0101 ^ 0011 = 0110)</li>
<li><code>~</code> (bitwise not) (eg- ~0101 = 1010)</li>
</ol>
</div>
</div>
<div id="outline-container-org61314cc" class="outline-3">
<h3 id="org61314cc"><span class="section-number-3">8.3.</span> Bit Masks</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>Used to block bitwise operators from modifying bits we don&rsquo;t want in a bitset, much like we use masking tape to block paint from touching certain parts of the product we&rsquo;re painting.</li>
<li>We can define bit masks as normal integers using either binary literals (c++14 or above) or by converting binary numbers to other literals such as decimals or hexadecimals.</li>
</ul>
</div>
<div id="outline-container-org25bd568" class="outline-4">
<h4 id="org25bd568"><span class="section-number-4">8.3.1.</span> Testing Bits using Masks</h4>
<div class="outline-text-4" id="text-8-3-1">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">creating masks</span>
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask1</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00000001</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask2</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00000010</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask3</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00000100</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask4</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00001000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask5</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00010000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask6</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00100000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask7</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">01000000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask8</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">10000000</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">testing if a bit at position 4 (starting from 0 from the right) is on or off using masks</span>
  <span class="org-type">std::uint8_t</span> <span class="org-variable-name">flags</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">01111011</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">arbitrary value</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"4th bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask5</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org7077180" class="outline-4">
<h4 id="org7077180"><span class="section-number-4">8.3.2.</span> Setting and Resetting Bits using Masks</h4>
<div class="outline-text-4" id="text-8-3-2">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">creating masks</span>
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask1</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00000001</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask2</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00000010</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask3</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00000100</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask4</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00001000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask5</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00010000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask6</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">00100000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask7</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">01000000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-constant">maybe_unused</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">constexpr</span> <span class="org-type">std::uint8_t</span> <span class="org-variable-name">mask8</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">10000000</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-type">std::uint8_t</span> <span class="org-variable-name">flags</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0b</span><span class="org-constant">01101101</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">turning flag 4 on</span>
  flags |= mask5; <span class="org-comment-delimiter">// </span><span class="org-comment">using bitwise OR</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">turning flag 0 off</span>
  flags &amp;= ~mask1; <span class="org-comment-delimiter">// </span><span class="org-comment">using bitwise AND and bitwise NOT</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">flipping bit 7</span>
  flags ^= mask8; <span class="org-comment-delimiter">// </span><span class="org-comment">using bitwise XOR</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">flipping bits 3 and 2 simultaneously</span>
  flags ^= <span class="org-rainbow-delimiters-depth-2">(</span>mask4 | mask3<span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 4th bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask5</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 0th bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask1</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 7th bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask8</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 3rd bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask4</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The 2rd bit is "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">flags</span> &amp; <span class="org-variable-name">mask3</span><span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-string">"on"</span> : <span class="org-string">"off"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>You may use <code>std::bitset</code> instead of <code>std::uint8_t</code> too!</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3306930" class="outline-3">
<h3 id="org3306930"><span class="section-number-3">8.4.</span> Example Hex Colour to RGBA Colour</h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">
<pre class="src src-bash">printf <span class="org-string">"FF03CA04"</span> &gt; /tmp/inp
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">bitset</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdint</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">defining masks</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">std::uint32_t</span> <span class="org-variable-name">redBits</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0x</span><span class="org-constant">FF000000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">constexpr</span> <span class="org-type">std::uint32_t</span> <span class="org-variable-name">blueBits</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0x</span><span class="org-constant">00FF0000</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">constexpr</span> <span class="org-type">std::uint32_t</span> <span class="org-variable-name">greenBits</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0x</span><span class="org-constant">0000FF00</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">constexpr</span> <span class="org-type">std::uint32_t</span> <span class="org-variable-name">alphaBits</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">0x</span><span class="org-constant">000000FF</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-type">std::uint32_t</span> <span class="org-variable-name">hexVal</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-constant">std</span>::cin &gt;&gt; <span class="org-constant">std</span>::hex &gt;&gt; hexVal; <span class="org-comment-delimiter">// </span><span class="org-comment">std::hex allows us to read in hex (input modifier)</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">getting individual colours as integers</span>
  <span class="org-type">int</span> <span class="org-variable-name">red</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">hexVal</span> &amp; <span class="org-variable-name">redBits</span><span class="org-rainbow-delimiters-depth-4">)</span> &gt;&gt; <span class="org-highlight-numbers-number">24</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">blue</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">hexVal</span> &amp; <span class="org-variable-name">blueBits</span><span class="org-rainbow-delimiters-depth-4">)</span> &gt;&gt; <span class="org-highlight-numbers-number">16</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">green</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">hexVal</span> &amp; <span class="org-variable-name">greenBits</span><span class="org-rainbow-delimiters-depth-4">)</span> &gt;&gt; <span class="org-highlight-numbers-number">8</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">alpha</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-type">hexVal</span> &amp; <span class="org-variable-name">alphaBits</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"rgba("</span> &lt;&lt; red &lt;&lt; <span class="org-string">","</span> &lt;&lt; blue &lt;&lt; <span class="org-string">","</span> &lt;&lt; green &lt;&lt; <span class="org-string">","</span> &lt;&lt; alpha &lt;&lt; <span class="org-string">")"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf026bff" class="outline-3">
<h3 id="orgf026bff"><span class="section-number-3">8.5.</span> Two&rsquo;s Complement</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li>Signed integers are typically stored in two&rsquo;s complement format.</li>
<li>In two&rsquo;s complement, the most significant bit (left most bit) is used to represent the sign of the number.</li>
<li>0 means positive and 1 means negative.</li>
<li>To convert a decimal number to a negative binary number, we invert all the bits and add 1.</li>
<li>Example, to convert -5 to binary, we first convert 5 to binary (0101) and then invert all the bits (1010) and add 1 (1011).</li>
<li>We add 1 because we need to represent 0 as 0000 and not 1111.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7b2c95e" class="outline-2">
<h2 id="org7b2c95e"><span class="section-number-2">9.</span> Namespaces</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>A namespace provides a scope region called the namespace scope which means that any thing defined in that scope won&rsquo;t be mistaken for anything else with the same name defined in some other namespace.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; x &lt;&lt; y &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">namespace</span> <span class="org-constant">mynamespace</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">defining an arbitrary function in this namespace</span>
  <span class="org-type">void</span> <span class="org-function-name">doSomething</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    ::print<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"hello "</span>, b<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">use print from the global namespace instead of this namespace</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">mynamespace</span>::doSomething<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">mynamespace</span>::a<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">mynamespace</span>;
  doSomething<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<blockquote>
<p>

</p>

<p>
Multiple definitions of the same namespace is allowed in C++.
</p>
</blockquote>
<ul class="org-ul">
<li>Nested namespaces can be accessed by doing something like <code>namespaceOne::namespaceTwo::hello</code>.</li>
</ul>
</div>
<div id="outline-container-org3e3921c" class="outline-3">
<h3 id="org3e3921c"><span class="section-number-3">9.1.</span> Namespace Aliases</h3>
<div class="outline-text-3" id="text-9-1">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">namespace</span> <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">namespace</span> <span class="org-constant">Goo</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-3">}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">namespace</span> <span class="org-constant">fg</span> = <span class="org-constant">Foo</span>::Goo;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">fg</span>::a &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Avoid deeply nested namespaces!
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org9653ff2" class="outline-2">
<h2 id="org9653ff2"><span class="section-number-2">10.</span> Scope, Duration and Lifetime</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>Scope is the region of code where an identifier is visible (global, local, namespace, block).</li>
<li>Duration specifies the start and end of the lifetime of an object (auto, static).</li>
<li>Lifetime is the time for which an object exists in memory.</li>
<li>Global variables have static duration by default.</li>
<li>Non constant integral global variables are initialized to 0 by default.</li>
</ul>
</div>
<div id="outline-container-orgf22df79" class="outline-3">
<h3 id="orgf22df79"><span class="section-number-3">10.1.</span> Name Hiding (Shadowing)</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>Whenever a name is defined in a scope, it hides any other name with the same name in the outer scope.</li>
<li>You should generally <i>avoid</i> variable shadowing.</li>
<li>In g++, you can use the <code>-Wshadow</code> flag to get warnings about shadowing.</li>
</ul>
</div>
</div>
<div id="outline-container-org14c381c" class="outline-3">
<h3 id="org14c381c"><span class="section-number-3">10.2.</span> Internal Linkage</h3>
<div class="outline-text-3" id="text-10-2">
<ul class="org-ul">
<li>Linkage is the property of an identifier which specifies whether it can be used in other translation units.</li>
<li>There are three types of linkages-
<ol class="org-ol">
<li>External Linkage</li>
<li>Internal Linkage</li>
<li>No Linkage</li>
</ol></li>
<li>Local variables have no linkage.</li>
<li>Non constant global variables have external linkage by default while constant global variables have internal linkage by default.</li>
<li>To make global variables have internal linkage, use the <code>static</code> keyword.</li>
<li>Functions have external linkage by default but can also be made to have internal linkage using the <code>static</code> keyword.</li>
</ul>
<blockquote>
<p>

</p>

<p>
It is recommended to give internal linkage to all global variables and functions that are not used in other translation units.
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Internal global variables definitions:</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">g_x</span>;          <span class="org-comment-delimiter">// </span><span class="org-comment">defines non-initialized internal global variable (zero initialized by default)</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">g_x</span><span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-highlight-numbers-number">1</span> <span class="org-rainbow-delimiters-depth-1">}</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized internal global variable</span>

<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-highlight-numbers-number">2</span> <span class="org-rainbow-delimiters-depth-1">}</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized internal global const variable</span>
<span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-highlight-numbers-number">3</span> <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized internal global constexpr variable</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Internal function definitions:</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{}</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">defines internal function</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc4a14fb" class="outline-3">
<h3 id="orgc4a14fb"><span class="section-number-3">10.3.</span> External Linkage</h3>
<div class="outline-text-3" id="text-10-3">
<ul class="org-ul">
<li>To make a variable or function have external linkage, use the <code>extern</code> keyword.</li>
<li>Global variables and functions have external linkage by default so you don&rsquo;t need to use the <code>extern</code> keyword.</li>
</ul>
<blockquote>
<p>

</p>

<p>
If you want to define an uninitialized non-const global variable, do not use the extern keyword, otherwise C++ will think youre trying to make a forward declaration for the variable
</p>
</blockquote>
<ul class="org-ul">
<li><code>constexpr</code> can be made to have external linkage by using the <code>extern</code> keyword however they can not be <i>forward declared</i>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">External global variable definitions:</span>
<span class="org-type">int</span> <span class="org-variable-name">g_x</span>;                       <span class="org-comment-delimiter">// </span><span class="org-comment">defines non-initialized external global variable (zero initialized by default)</span>
<span class="org-keyword">extern</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">g_x</span><span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-highlight-numbers-number">1</span> <span class="org-rainbow-delimiters-depth-1">}</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized const external global variable</span>
<span class="org-keyword">extern</span> <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">g_x</span><span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-highlight-numbers-number">2</span> <span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">defines initialized constexpr external global variable</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Forward declarations</span>
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span>;                <span class="org-comment-delimiter">// </span><span class="org-comment">forward declaration for non-constant global variable</span>
<span class="org-keyword">extern</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span>;          <span class="org-comment-delimiter">// </span><span class="org-comment">forward declaration for const global variable</span>
<span class="org-keyword">extern</span> <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">g_y</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">not allowed: constexpr variables can't be forward declared</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5abfaf5" class="outline-3">
<h3 id="org5abfaf5"><span class="section-number-3">10.4.</span> Non-constant Global Variables are Evil</h3>
<div class="outline-text-3" id="text-10-4">
<ul class="org-ul">
<li>They can be changed from anywhere in the program.</li>
</ul>
<blockquote>
<p>

</p>

<p>
Dynamic initialization of global variables causes a lot of problems in C++. Avoid dynamic initialization whenever possible.
</p>
</blockquote>
<ul class="org-ul">
<li>Prefer using namespaces to avoid name collisions.</li>
<li>In functions, prefer passing variables as parameters instead of using global variables.</li>
</ul>
</div>
</div>
<div id="outline-container-org1646c76" class="outline-3">
<h3 id="org1646c76"><span class="section-number-3">10.5.</span> Sharing Global Variables Across Files</h3>
<div class="outline-text-3" id="text-10-5">
<ul class="org-ul">
<li>You can create header files, define a namespace, define the constants as <code>constexpr</code> and then include the header file in all files where you want to use the constants.</li>
<li>This approach has some downsides-
<ol class="org-ol">
<li>If the header file is used in 20 files, the definitions will be duplicated 20 times and each file will have to be recompiled if the header file is changed.</li>
<li>If the constants are large, it will increase memory usage because of duplication!</li>
</ol></li>
<li>Another approach is to define a namespace in a <code>.cpp</code> file, define the constants using <code>extern const</code> in the namespace, forward declare the constants in a <code>.h</code> header file and then include the header file in all files where you want to use the constants.</li>
<li>This approach also has some downsides-
<ol class="org-ol">
<li>These constants will now be considered compile-time only in the <code>.cpp</code> file in which they are defined because the linker will only see the forward declaration from the header file.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orga79f6a6" class="outline-3">
<h3 id="orga79f6a6"><span class="section-number-3">10.6.</span> Global Constants as Inline Variables</h3>
<div class="outline-text-3" id="text-10-6">
<ul class="org-ul">
<li>For C++17 and above, you can use inline variables to define global constants.</li>
<li>These variables are better than macros because they are type safe and can be debugged.</li>
<li>They are better than global constants because they are not duplicated across files.</li>
<li><p>
Prefer using them over the above two methods of sharing global variables across files.
</p>

<p>
<code>constants.h</code>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#IFNDEF</span> <span class="org-constant">CONSTANTS_H</span>
<span class="org-preprocessor">#DEFINE</span> <span class="org-constant">CONSTANTS_H</span>
<span class="org-keyword">namespace</span> <span class="org-constant">constants</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">pi</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">3.14159</span><span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-preprocessor">#ENDIF</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org9313988" class="outline-3">
<h3 id="org9313988"><span class="section-number-3">10.7.</span> Static on local variables</h3>
<div class="outline-text-3" id="text-10-7">
<ul class="org-ul">
<li>Using the static keyword on local variables changes its duration to be created at the start of the program and destroyed at the end.</li>
<li>It is common to use the <code>s_</code> prefix on static variable identifiers.</li>
<li>You should avoid static local variables unless the variable never needs to be reset as this can cause confusion.</li>
</ul>
</div>
</div>
<div id="outline-container-org1ff6707" class="outline-3">
<h3 id="org1ff6707"><span class="section-number-3">10.8.</span> Summary</h3>
<div class="outline-text-3" id="text-10-8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Type</td>
<td class="org-left">Example</td>
<td class="org-left">Scope</td>
<td class="org-left">Duration</td>
<td class="org-left">Linkage</td>
<td class="org-left">Notes</td>
</tr>

<tr>
<td class="org-left">Local variable</td>
<td class="org-left"><code>int x;</code></td>
<td class="org-left">Block</td>
<td class="org-left">Automatic</td>
<td class="org-left">None</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Static local variable</td>
<td class="org-left"><code>static int s_x;</code></td>
<td class="org-left">Block</td>
<td class="org-left">Static</td>
<td class="org-left">None</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Dynamic local variable</td>
<td class="org-left"><code>int* x { new int{} };</code></td>
<td class="org-left">Block</td>
<td class="org-left">Dynamic</td>
<td class="org-left">None</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Function parameter</td>
<td class="org-left"><code>void foo(int x)</code></td>
<td class="org-left">Block</td>
<td class="org-left">Automatic</td>
<td class="org-left">None</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">External non-constant global variable</td>
<td class="org-left"><code>int g_x;</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">External</td>
<td class="org-left">Initialized or uninitialized</td>
</tr>

<tr>
<td class="org-left">Internal non-constant global variable</td>
<td class="org-left"><code>static int g_x;</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">Internal</td>
<td class="org-left">Initialized or uninitialized</td>
</tr>

<tr>
<td class="org-left">Internal constant global variable</td>
<td class="org-left"><code>constexpr int g_x { 1 };</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">Internal</td>
<td class="org-left">Must be initialized</td>
</tr>

<tr>
<td class="org-left">External constant global variable</td>
<td class="org-left"><code>extern const int g_x { 1 };</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">External</td>
<td class="org-left">Must be initialized</td>
</tr>

<tr>
<td class="org-left">Inline constant global variable (C++17)</td>
<td class="org-left"><code>inline constexpr int g_x { 1 };</code></td>
<td class="org-left">Global</td>
<td class="org-left">Static</td>
<td class="org-left">External</td>
<td class="org-left">Must be initialized</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org4acc6fc" class="outline-2">
<h2 id="org4acc6fc"><span class="section-number-2">11.</span> Using Declarations</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org938562e" class="outline-3">
<h3 id="org938562e"><span class="section-number-3">11.1.</span> Qualified and unqualified names</h3>
<div class="outline-text-3" id="text-11-1">
<p>
A qualified name is one which has been resolved using the namespace operator (<code>::</code>) or the member selection operators (<code>.</code>, <code>-&gt;</code>).
For example, <code>std::cout</code>, <code>std::pow(5, 3)</code>, <code>student.name</code> etc..
</p>
</div>
</div>
<div id="outline-container-orgafb6791" class="outline-3">
<h3 id="orgafb6791"><span class="section-number-3">11.2.</span> Using-declarations</h3>
<div class="outline-text-3" id="text-11-2">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-constant">cout</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">specifying the exact object that we'd like to use</span>
  cout &lt;&lt; <span class="org-string">"Hello World\n"</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org38787bb" class="outline-3">
<h3 id="org38787bb"><span class="section-number-3">11.3.</span> Using-directives</h3>
<div class="outline-text-3" id="text-11-3">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">importing the entire namespace into the current scope</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Prefer explicit namespaces over using-statements. Avoid using-directives whenever possible. Using-declarations are okay to use inside blocks.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orga582dc6" class="outline-2">
<h2 id="orga582dc6"><span class="section-number-2">12.</span> Control Flow</h2>
<div class="outline-text-2" id="text-12">
<ul class="org-ul">
<li>The specific sequence of statements that the CPU executes is called the program&rsquo;s <b>execution path</b>.</li>
</ul>
</div>
<div id="outline-container-org742e590" class="outline-3">
<h3 id="org742e590"><span class="section-number-3">12.1.</span> Null Statements</h3>
<div class="outline-text-3" id="text-12-1">
<ul class="org-ul">
<li>Statements that just contain the semicolon <code>;</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-2">)</span>
    ;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org64fc7c8" class="outline-3">
<h3 id="org64fc7c8"><span class="section-number-3">12.2.</span> <code>constexpr</code> if statements</h3>
<div class="outline-text-3" id="text-12-2">
<ul class="org-ul">
<li><p>
Consider the following code-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

  <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">pi</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">3.14</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>pi == <span class="org-highlight-numbers-number">3.14</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Hello World"</span><span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Goodbye World"</span><span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">This will never be printed</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>The condition above is <i>always</i> true.</li>
<li><p>
This is wasteful at runtime so C++17 introduced constexpr if statements-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

  <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">pi</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">3.14</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">if</span> <span class="org-keyword">constexpr</span> <span class="org-rainbow-delimiters-depth-2">(</span>pi == <span class="org-highlight-numbers-number">3.14</span><span class="org-rainbow-delimiters-depth-2">)</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"pi is 3.14"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">else</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"pi is not 3.14"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org836b770" class="outline-3">
<h3 id="org836b770"><span class="section-number-3">12.3.</span> The <code>[[fallthrough]]</code> attribute</h3>
<div class="outline-text-3" id="text-12-3">
<ul class="org-ul">
<li>When using switch statements, if we do not use the <code>break</code> or <code>return</code> keyword, the cases following the matched case will also be executed which is known as a fallthrough.</li>
<li>This is not desired mostly but when it is, we can tell the compiler to avoid giving a warning by using the <code>[[fallthrough]]</code> attribute.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">switch</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-keyword">case</span> <span class="org-highlight-numbers-number">1</span>:
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"1"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">break</span>;
  <span class="org-keyword">case</span> <span class="org-highlight-numbers-number">2</span>:
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"2"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-rainbow-delimiters-depth-4">[</span><span class="org-constant">fallthrough</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">]</span>;
  <span class="org-keyword">case</span> <span class="org-highlight-numbers-number">3</span>:
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"3"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">break</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Note that the semicolon used along with the <code>[[fallthrough]]</code> attribute is a <code>null</code> statement.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org9340504" class="outline-3">
<h3 id="org9340504"><span class="section-number-3">12.4.</span> Halting Programs</h3>
<div class="outline-text-3" id="text-12-4">
<ul class="org-ul">
<li>You can halt a program using <code>std::exit()</code> from <code>cstdlib</code>.</li>
<li>This function does not, however, clean up memory reserved for the local variables.</li>
<li>Always use the <code>std::atexit(callback)</code> function which runs the callback function provided to it whenever <code>std::exit()</code> has been called.</li>
</ul>
<blockquote>
<p>

</p>

<p>
You should <i>never</i> use halt functions explicitly unless there&rsquo;s no safe way to exit the program.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org2bdbc06" class="outline-2">
<h2 id="org2bdbc06"><span class="section-number-2">13.</span> Randomness</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li>Algorithms that simulate generating random numbers are called &ldquo;Pseudo Random Number Generators (PRNGs)&rdquo;.</li>
<li>An initial value called the <code>seed</code> is provided to every PRNG to generate random numbers.</li>
<li>To further generate random numbers, the initial seed is modified by some mathematical calculations and then the new value is used.</li>
<li>The <span class="underline">state</span> of an algorithm is the value that the stateful algorithm keeps.</li>
<li>An algorithm is considered to be stateful if it retains some information across calls.</li>
<li>When, for a PRNG, the size of the seed provided is less than the intended size of the state, the PRNG is said to be <i>underseeded</i>.</li>
<li>Underseeded PRNGs will produce low quality random numbers.</li>
</ul>
</div>
<div id="outline-container-org17d966f" class="outline-3">
<h3 id="org17d966f"><span class="section-number-3">13.1.</span> Built-in PRNGs in C++</h3>
<div class="outline-text-3" id="text-13-1">
<ul class="org-ul">
<li>In the <code>&lt;random&gt;</code> library, there are 6 PRNGs available for use (as of C++20).</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Type name</th>
<th scope="col" class="org-left">Family</th>
<th scope="col" class="org-left">Period</th>
<th scope="col" class="org-left">State size*</th>
<th scope="col" class="org-left">Performance</th>
<th scope="col" class="org-left">Quality</th>
<th scope="col" class="org-left">Should I use this?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>minstd_rand</code></td>
<td class="org-left">Linear congruential generator</td>
<td class="org-left">2<sup>31</sup></td>
<td class="org-left">4 bytes</td>
<td class="org-left">Bad</td>
<td class="org-left">Awful</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left"><code>minstd_rand0</code></td>
<td class="org-left">Linear congruential generator</td>
<td class="org-left">2<sup>31</sup></td>
<td class="org-left">4 bytes</td>
<td class="org-left">Bad</td>
<td class="org-left">Awful</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">mt19937</td>
<td class="org-left">Mersenne twister</td>
<td class="org-left">2<sup>19937</sup></td>
<td class="org-left">2500 bytes</td>
<td class="org-left">Decent</td>
<td class="org-left">Decent</td>
<td class="org-left">Probably (see next section)</td>
</tr>

<tr>
<td class="org-left"><code>mt19937_64</code></td>
<td class="org-left">Mersenne twister</td>
<td class="org-left">2<sup>19937</sup></td>
<td class="org-left">2500 bytes</td>
<td class="org-left">Decent</td>
<td class="org-left">Decent</td>
<td class="org-left">Probably (see next section)</td>
</tr>

<tr>
<td class="org-left">ranlux24</td>
<td class="org-left">Subtract and carry</td>
<td class="org-left">10<sup>171</sup></td>
<td class="org-left">96 bytes</td>
<td class="org-left">Awful</td>
<td class="org-left">Good</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">ranlux48</td>
<td class="org-left">Subtract and carry</td>
<td class="org-left">10<sup>171</sup></td>
<td class="org-left">96 bytes</td>
<td class="org-left">Awful</td>
<td class="org-left">Good</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">knuth<sub>b</sub></td>
<td class="org-left">Shuffled linear congruential generator</td>
<td class="org-left">2<sup>31</sup></td>
<td class="org-left">1028 bytes</td>
<td class="org-left">Awful</td>
<td class="org-left">Bad</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">default<sub>random</sub><sub>engine</sub></td>
<td class="org-left">Any of above (implementation defined)</td>
<td class="org-left">Varies</td>
<td class="org-left">Varies</td>
<td class="org-left">?</td>
<td class="org-left">?</td>
<td class="org-left">No2</td>
</tr>

<tr>
<td class="org-left">rand()</td>
<td class="org-left">Linear congruential generator</td>
<td class="org-left">2<sup>31</sup></td>
<td class="org-left">4 bytes</td>
<td class="org-left">Bad</td>
<td class="org-left">Awful</td>
<td class="org-left">Nono</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>We should only use the Mersenne twister PRNG out of all the other built-in methods (if you don&rsquo;t have the choice to use third party libraries).</li>
<li><code>mt19937</code> generates 32 bit unsigned integers while <code>mt19937_64</code> generates 64 bit unsigned integers.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">initializing</span>
  <span class="org-constant">std</span>::cout &lt;&lt; mt<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">using mt() is the preferred way to call the mt.operator() method</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>To generate numbers within a range with unbiased results (i.e. each number has an equal chance of being generated), we can use the <code>std::uniform_int_distribution</code> class.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{}</span>;

  <span class="org-constant">std</span>::<span class="org-type">uniform_int_distribution</span> <span class="org-variable-name">dice</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">printing a bunch of random numbers</span>
  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">count</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-3">}</span>; count &lt;= <span class="org-highlight-numbers-number">40</span>; count++<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; dice<span class="org-rainbow-delimiters-depth-3">(</span>mt<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-string">' '</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>We can use <code>std::chrono</code> to seed the PRNG with the current time (it stores the time in &ldquo;ticks&rdquo; which is usually in nanoseconds or microseconds!).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">mt19937</span>::result_type<span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-4">()</span>.time_since_epoch<span class="org-rainbow-delimiters-depth-4">()</span>.count<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-constant">std</span>::<span class="org-type">uniform_int_distribution</span> <span class="org-variable-name">dice</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-3">}</span>; i &lt;= <span class="org-highlight-numbers-number">40</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; dice<span class="org-rainbow-delimiters-depth-3">(</span>mt<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-string">' '</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>You can also seed using the system&rsquo;s random device (recommended over system time)-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">std</span>::random_device<span class="org-rainbow-delimiters-depth-3">{}()</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-constant">std</span>::<span class="org-type">uniform_int_distribution</span> <span class="org-variable-name">dice</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">}</span>; i &lt; <span class="org-highlight-numbers-number">40</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; dice<span class="org-rainbow-delimiters-depth-2">(</span>mt<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">' '</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
<code>std::random_device</code> also generates random numbers but should not be used as a PRNG because it is implementation defined, may not be available on all platforms, and might produce low quality results on different compilers.
</p>
</blockquote>
<ul class="org-ul">
<li>The internal state of Mersenne twister is 624 bytes in size.</li>
<li>The seeds we provided above were only 4 bytes in size causing the PRNG to be heavily underseeded.</li>
<li><code>std::seed_seq</code> can be used to provide a seed sequence to the PRNG.</li>
<li>We can provide as many random values to <code>std::seed_seq</code> as we want and it generate unbiased seed values with the required size for the PRNG.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">random</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">random_device</span> <span class="org-variable-name">rd</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-constant">std</span>::<span class="org-type">seed_seq</span> <span class="org-variable-name">ss</span><span class="org-rainbow-delimiters-depth-2">{</span>rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span>, rd<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">8 random integers</span>
  <span class="org-constant">std</span>::<span class="org-type">mt19937</span> <span class="org-variable-name">mt</span><span class="org-rainbow-delimiters-depth-2">{</span>ss<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">initializing using the seed sequence</span>

  <span class="org-constant">std</span>::<span class="org-type">uniform_int_distribution</span> <span class="org-variable-name">dice</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">}</span>; i &lt; <span class="org-highlight-numbers-number">40</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; dice<span class="org-rainbow-delimiters-depth-2">(</span>mt<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">' '</span>;

  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1b76f0f" class="outline-2">
<h2 id="org1b76f0f"><span class="section-number-2">14.</span> Software Testing</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-orgf4fe441" class="outline-3">
<h3 id="orgf4fe441"><span class="section-number-3">14.1.</span> Informal Testing</h3>
<div class="outline-text-3" id="text-14-1">
<ul class="org-ul">
<li>Informal testing is the process of testing a program by running it and observing its behaviour.</li>
<li>After writing a program, you just run it with a few different inputs and see if it works as expected.</li>
<li>We can write functions that test&rsquo;s the program&rsquo;s functions by comparing their outputs with expected results.</li>
<li>You can also use <code>assert</code> to check if a condition is true and if it isn&rsquo;t, the program will halt.</li>
</ul>
</div>
</div>
<div id="outline-container-org8fa6a37" class="outline-3">
<h3 id="org8fa6a37"><span class="section-number-3">14.2.</span> Code Coverage</h3>
<div class="outline-text-3" id="text-14-2">
<ul class="org-ul">
<li>Code coverage is a measure of how much of the code is executed when the program is executed while testing.</li>
<li>Similarly, the term <b>statement coverage</b> refers to the percentage of statements that are executed during testing.</li>
<li><b>Branch coverage</b> refers to the percentage of branches that are executed during testing.</li>
<li><b>Loop coverage</b> says that if you have a loop, you should test it with 0, 1, and 2 iterations. If it works for the second iteration, it will work for all other iterations.</li>
</ul>
</div>
</div>
<div id="outline-container-org65c2633" class="outline-3">
<h3 id="org65c2633"><span class="section-number-3">14.3.</span> Symantic Errors</h3>
<div class="outline-text-3" id="text-14-3">
<ul class="org-ul">
<li>Errors that occur when the program is running and are not caught by the compiler (logical type of errors).</li>
<li>Some semantic errors include:
<ul class="org-ul">
<li>Division by zero</li>
<li>Precision errors</li>
<li>Comparison logical errors</li>
<li>Not using blocks for if statements</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5b716ae" class="outline-3">
<h3 id="org5b716ae"><span class="section-number-3">14.4.</span> Detecting and Handling Errors</h3>
<div class="outline-text-3" id="text-14-4">
<ul class="org-ul">
<li>Most of the time, errors are caused because the programmer made some faulty assumptions like the user will always enter a number when the program asks for a number, the student being look up will always be in the database, etc.</li>
</ul>
</div>
</div>
<div id="outline-container-org105313f" class="outline-3">
<h3 id="org105313f"><span class="section-number-3">14.5.</span> Handling String Input</h3>
<div class="outline-text-3" id="text-14-5">
</div>
<div id="outline-container-org4a601d0" class="outline-4">
<h4 id="org4a601d0"><span class="section-number-4">14.5.1.</span> Error Case 1: Extraction succeeds but input is meaningless</h4>
<div class="outline-text-4" id="text-14-5-1">
<ul class="org-ul">
<li>For example, required input values were &ldquo;y&rdquo; or &ldquo;n&rdquo; but the input entered was &ldquo;q&rdquo;.</li>
<li>Solving these is easy. Just use a while loop until the user enters one of the required values.</li>
</ul>
</div>
</div>
<div id="outline-container-org1a02944" class="outline-4">
<h4 id="org1a02944"><span class="section-number-4">14.5.2.</span> Error Case 2: Input buffer already had some characters</h4>
<div class="outline-text-4" id="text-14-5-2">
<ul class="org-ul">
<li>In cases where the input buffer already had some items.</li>
<li>You can tell the compiler to clear the input buffer after taking input using <code>std::cin.ignore(100, '\n')</code>.</li>
<li>The above method will clear 100 characters out of the buffer OR until the newline is encountered.</li>
<li><p>
To ignore everything upto and including the <code>\n</code>, we use-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">std</span>::cin.ignore<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">numeric_limits</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::streamsize<span class="org-rainbow-delimiters-depth-2">&gt;</span>::max<span class="org-rainbow-delimiters-depth-2">()</span>, <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div></li>
<li><p>
We can use <code>std::cin.peek()</code> to peek at the next character in the input buffer like this-
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">char</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-constant">std</span>::cin &gt;&gt; c;

    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span><span class="org-constant">std</span>::cin.eof<span class="org-rainbow-delimiters-depth-3">()</span> &amp;&amp; <span class="org-constant">std</span>::cin.peek<span class="org-rainbow-delimiters-depth-3">()</span> != <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">clear input buffer</span>
      <span class="org-constant">std</span>::cin.ignore<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">numeric_limits</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::streamsize<span class="org-rainbow-delimiters-depth-4">&gt;</span>::max<span class="org-rainbow-delimiters-depth-4">()</span>, <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-keyword">continue</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org9c42c5e" class="outline-4">
<h4 id="org9c42c5e"><span class="section-number-4">14.5.3.</span> Error Case 3: Extraction fails and program goes in an infinite loop</h4>
<div class="outline-text-4" id="text-14-5-3">
<ul class="org-ul">
<li>Whenever an invalid value is present in the input buffer (for example, a <code>char</code> when <code>int</code> was asked), the value stays in the buffer and the program again searches the buffer (going into an infinite loop).</li>
<li><p>
We can prevent this by doing-
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cin.fail<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">If EOF character was inserted (on pressing Ctrl+D)</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin.eof<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        exit<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">shut down the program now</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::cin.clear<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">used to unset the "failbit" after bad input, i.e., putting back to normal mode</span>
    <span class="org-constant">std</span>::cin.ignore<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">numeric_limits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::streamsize<span class="org-rainbow-delimiters-depth-3">&gt;</span>::max<span class="org-rainbow-delimiters-depth-3">()</span>, <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>We can also just test for failure like this- <code>if (!std::cin)</code>.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2497fca" class="outline-3">
<h3 id="org2497fca"><span class="section-number-3">14.6.</span> Assertions</h3>
<div class="outline-text-3" id="text-14-6">
<ul class="org-ul">
<li>Preconditions are the conditions that must be true before a function is called.</li>
<li>An <b>invariant</b> is a condition that must be true while some section of code is executing. This is often used with loops, where the loop body will only execute so long as the invariant is true.</li>
<li>Postconditions are the conditions that must be true after a function is called.</li>
</ul>
</div>
<div id="outline-container-org635f41f" class="outline-4">
<h4 id="org635f41f"><span class="section-number-4">14.6.1.</span> Assert</h4>
<div class="outline-text-4" id="text-14-6-1">
<ul class="org-ul">
<li>An assertion is a statement that which takes a condition which, if false, will print an error message and run <code>std::abort()</code>.</li>
<li><p>
You can use the <code>assert</code> macro to check if a condition is true.
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-type">void</span> <span class="org-function-name">printAge</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">age</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    assert<span class="org-rainbow-delimiters-depth-2">(</span>age &gt;= <span class="org-highlight-numbers-number">0</span> &amp;&amp; <span class="org-string">"Age must be positive"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"I am "</span> &lt;&lt; age &lt;&lt; <span class="org-string">" years old"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Assert statements should NOT be used in production code as they come with a performance cost and the program must have already been checked for any errors.</li>
<li>The <code>NDEBUG</code> flag disables assert statements.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3a6fb02" class="outline-4">
<h4 id="org3a6fb02"><span class="section-number-4">14.6.2.</span> Static Assert</h4>
<div class="outline-text-4" id="text-14-6-2">
<ul class="org-ul">
<li>Instead of a macro, it is a keyword.</li>
<li>It is used to check if a condition is true at <b>compile time</b>.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc7531d4" class="outline-2">
<h2 id="orgc7531d4"><span class="section-number-2">15.</span> Type Conversions, Type Aliases, Type Deduction</h2>
<div class="outline-text-2" id="text-15">
</div>
<div id="outline-container-orgff4c0d1" class="outline-3">
<h3 id="orgff4c0d1"><span class="section-number-3">15.1.</span> Implicit Type Conversions</h3>
<div class="outline-text-3" id="text-15-1">
<ul class="org-ul">
<li>Performed automatically by the compiler.</li>
<li>If the conversion can not be performed, the compiler will throw an error.</li>
</ul>
</div>
<div id="outline-container-org599012d" class="outline-4">
<h4 id="org599012d"><span class="section-number-4">15.1.1.</span> Numeric Promotions</h4>
<div class="outline-text-4" id="text-15-1-1">
<ul class="org-ul">
<li>A numeric promotion is an implicit type conversion where narrower data types (like char) are converted to wider data types (like int and long) that can be processed efficiently.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org9cfd303"></a>Floating Point Promotions<br />
<div class="outline-text-5" id="text-15-1-1-1">
<p>
A value of type float is promoted to double.
</p>
</div>
</li>
<li><a id="org7d767fb"></a>Integral Promotions<br />
<div class="outline-text-5" id="text-15-1-1-2">
<p>
A value of type char, signed char, unsigned char, short, or unsigned short is promoted to an int if an int can represent all the values of the original type.
</p>
</div>
</li>
<li><a id="org95a4a17"></a>Safe Conversions<br />
<div class="outline-text-5" id="text-15-1-1-3">
<p>
Conversions in which the original value (the meaning) does not change. For example, converting an int to a long.
</p>
</div>
</li>
<li><a id="org8bf8c12"></a>Reinterpretative Conversions<br />
<div class="outline-text-5" id="text-15-1-1-4">
<p>
Conversions which are considered unsafe where the result may be outside the range of the source type. This includes signed/unsigned conversions.
</p>
</div>
</li>
<li><a id="org9131248"></a>Lossy Conversions<br />
<div class="outline-text-5" id="text-15-1-1-5">
<p>
Conversions in which the some/whole part of the original value is lost. For example, converting a double to an int or double with many decimal places to a float (low precision causes loss of some decimal values).
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org4b32336" class="outline-3">
<h3 id="org4b32336"><span class="section-number-3">15.2.</span> Narrowing Conversions</h3>
<div class="outline-text-3" id="text-15-2">
<ul class="org-ul">
<li>From a floating point type to an integer type (unless it&rsquo;s constexpr <i>or</i> decimal places are zero).</li>
<li>From an integral type to a floating type.</li>
<li>From an integral type to a narrower integral type (unless it&rsquo;s constexpr <i>or</i> in range).</li>
<li>These are unsafe and should be avoided.</li>
<li>In some cases, you may want to explicitly do a narrowing conversion. You can do this using the <code>static_cast</code> operator.</li>
</ul>
</div>
</div>
<div id="outline-container-org47cd5ed" class="outline-3">
<h3 id="org47cd5ed"><span class="section-number-3">15.3.</span> Type Aliases</h3>
<div class="outline-text-3" id="text-15-3">
<ul class="org-ul">
<li>We use the <code>using</code> keyword to define type aliases.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">using</span> <span class="org-type">Distance</span> = <span class="org-type">double</span>;
<span class="org-type">Distance</span> <span class="org-variable-name">homeToSchool</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">3.55</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>It&rsquo;s a convention to name aliases starting with a capital letter.</li>
<li>We can also use <code>typedef</code> from C in C++ (but it&rsquo;s only present for backwards compatibility and its syntax can get very confusing).</li>
<li>The <code>std::int8_t</code> type is just an alias to <code>char</code> which is exactly why we get a character value when using it.</li>
</ul>
</div>
</div>
<div id="outline-container-orgb4c700a" class="outline-3">
<h3 id="orgb4c700a"><span class="section-number-3">15.4.</span> Type Deduction</h3>
<div class="outline-text-3" id="text-15-4">
<ul class="org-ul">
<li>We defining a variable, for example <code>double distance {5.76};</code>, the literal <code>5.76</code> has the type double and we have explicitly mentioned <code>double</code> as the data type of <code>distance</code>, providing the same information twice.</li>
<li>The compiler can deduce the type automatically in such cases using- <code>auto distance {5.76};</code></li>
<li><p>
Type deduction doesn&rsquo;t work if the return value of a function is void, for example-
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

  <span class="org-type">void</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">test</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>

  <span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span>test<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Not valid</span>
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>Using <code>auto</code> will drop <code>const</code> and <code>constexpr</code> from the type.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">num</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-1">{</span>num<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">a is of type int, not constexpr int</span>

<span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">b</span> <span class="org-rainbow-delimiters-depth-1">{</span>num<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">b is of type constexpr int</span>
</pre>
</div>
<ul class="org-ul">
<li>Normal string literals default to the type <code>const char*</code>, so to use <code>std::string</code> or <code>std::string_view</code>, use literal suffixes- <code>"hello"std::literals::s</code> or <code>"hello"std::literals::sv</code>.</li>
<li>In such cases, it may be better to not use <code>auto</code> and just use the type explicitly.</li>
<li><p>
You can also use <code>auto</code> with functions, however this is NOT recommended.
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-keyword">auto</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> a + b;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li><p>
The following is also valid
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-keyword">auto</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> a + b;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
<li>Type deductions can&rsquo;t be used for function parameters, like <code>int add(auto a, autob);</code> is not valid.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd024e52" class="outline-2">
<h2 id="orgd024e52"><span class="section-number-2">16.</span> Function Overloading</h2>
<div class="outline-text-2" id="text-16">
<ul class="org-ul">
<li>Function overloading is the process of defining multiple functions with the same name but different parameters.</li>
<li>The compiler will choose the function to call based on the type of the parameters.</li>
<li>Function overloading is allowed so long as the compiler can differntiate between the functions (else, compiler error).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-type">int</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">result</span> = a + b;
  <span class="org-keyword">return</span> result;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">double</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">double</span> <span class="org-variable-name">result</span> = a + b;
  <span class="org-keyword">return</span> result;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; add<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">5</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; add<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">5.5</span>, <span class="org-highlight-numbers-number">3.3</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Unexpectedly, there are no downsides to function overloading and it can/should be used liberally.</li>
</ul>
</div>
<div id="outline-container-orgd7b9518" class="outline-3">
<h3 id="orgd7b9518"><span class="section-number-3">16.1.</span> Function Overload Differentiation</h3>
<div class="outline-text-3" id="text-16-1">
<ul class="org-ul">
<li>The compiler differentiates between functions by looking at the <b>number of parameters</b> and their <b>types</b>.</li>
<li>The return type of a function is not considered when differentiating between functions.</li>
<li>Qualifiers like <code>const</code> are also not considered when differentiating between functions.</li>
</ul>
</div>
</div>
<div id="outline-container-orgbc0806a" class="outline-3">
<h3 id="orgbc0806a"><span class="section-number-3">16.2.</span> Resolving Overloaded Function Calls</h3>
<div class="outline-text-3" id="text-16-2">
<ul class="org-ul">
<li>Resolving overloaded function calls is the process of the compiler choosing which function to call when an overloaded function is called.</li>
<li>It goes through these steps-
<ol class="org-ol">
<li>The compiler will look for an exact match for the function call.</li>
<li>If step 1 fails, the compiler will perform numeric promotions and look for a match.</li>
<li>If step 2 fails, the compiler will perform numeric conversions and look for a match.</li>
<li>If step 3 fails, the compiler will look for a match using the user-defined conversions.</li>
<li>If step 4 fails, the compiler will look for a matching function that uses ellipsis.</li>
<li>If step 5 fails, the compiler will throw an error.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orgcfab2ee" class="outline-3">
<h3 id="orgcfab2ee"><span class="section-number-3">16.3.</span> Deleting Functions</h3>
<div class="outline-text-3" id="text-16-3">
<ul class="org-ul">
<li>You can prohibit certain function calls by using the <code>delete</code> keyword.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-type">int</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> a + b;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span> <span class="org-variable-name">a</span>, <span class="org-type">char</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-keyword">delete</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">if called, the program will not compile</span>
<span class="org-type">void</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-keyword">delete</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">if called, the program will not compile</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  add<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">5</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  add<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'a'</span>, <span class="org-string">'b'</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will not compile</span>
  add<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">5.5</span>, <span class="org-highlight-numbers-number">3.3</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will not compile</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfabd2f5" class="outline-3">
<h3 id="orgfabd2f5"><span class="section-number-3">16.4.</span> Default Arguments</h3>
<div class="outline-text-3" id="text-16-4">
<ul class="org-ul">
<li>Default arguments are used to provide a default value for a function parameter.</li>
<li>The default arguments should be specified in forward declarations (function prototype) and not in the function definition.</li>
<li>Example: <code>int add(int a, int b = 0);</code></li>
</ul>
<blockquote>
<p>
BEST PRACTICE:
If the function has a forward declaration (especially one in a header file), put the default argument there. Otherwise, put the default argument in the function definition. For example, in the forward declaration do this <code>int add(int x=5, int y=7)</code> and in the definition, do this <code>int add(int x, int y)</code>.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgd5d76b2" class="outline-2">
<h2 id="orgd5d76b2"><span class="section-number-2">17.</span> Function Templates</h2>
<div class="outline-text-2" id="text-17">
<ul class="org-ul">
<li>The generic type is specified using a template parameter.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">T</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">a</span>, <span class="org-type">T</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> a + b;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>The <code>typename</code> or the <code>class</code> keyword is used to specify a template parameter (it doesn&rsquo;t matter if you use <code>class</code> or <code>typename</code>, both mean the same).</li>
<li>A function template is used to generate functions. Function templates themselves are not functions.</li>
<li>We can call the add function doing something like this- <code>add&lt;int&gt;(5, 6)</code>. The compiler will see that a function definition for <code>add</code> does not already exist, so it will generate one.</li>
<li>When the data types of arguments matches the typename of the template, we can simply let the compiler deduce the typename doing something like this- <code>add&lt;&gt;(5, 6)</code> or simply <code>add(5,6)</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">T</span> <span class="org-function-name">getMax</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">a</span>, <span class="org-type">T</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>a &gt; b<span class="org-rainbow-delimiters-depth-2">)</span> ? a : b;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">char</span> <span class="org-function-name">getMax</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span> <span class="org-variable-name">a</span>, <span class="org-type">char</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>a &gt; b<span class="org-rainbow-delimiters-depth-2">)</span> ? a : b;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getMax<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-highlight-numbers-number">5</span>, <span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">calls getMax&lt;int&gt;(int, int)</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getMax<span class="org-rainbow-delimiters-depth-2">&lt;&gt;(</span><span class="org-highlight-numbers-number">5</span>, <span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">calls getMax&lt;int&gt;(int, int), not template functions are not considered</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getMax<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">5</span>, <span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">will call getMax(char, char)</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
<div id="outline-container-orgcd90fcc" class="outline-3">
<h3 id="orgcd90fcc"><span class="section-number-3">17.1.</span> Forward Declaring Function Templates</h3>
<div class="outline-text-3" id="text-17-1">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span>
<span class="org-type">T</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">a</span>, <span class="org-type">T</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbebf446" class="outline-3">
<h3 id="orgbebf446"><span class="section-number-3">17.2.</span> Including Function Templates</h3>
<div class="outline-text-3" id="text-17-2">
<ul class="org-ul">
<li>You can define function templates inside header files since they are exempted from the one definition rule.</li>
<li>This allows the compiler to see the full definition of the template and instantiate functions whenever needed.</li>
<li>Using forward declarations won&rsquo;t work for function templates.</li>
</ul>
</div>
</div>
<div id="outline-container-org5a49bdb" class="outline-3">
<h3 id="org5a49bdb"><span class="section-number-3">17.3.</span> Abbreviated Function Templates</h3>
<div class="outline-text-3" id="text-17-3">
<ul class="org-ul">
<li>For C++20 and above only.</li>
<li><p>
Defines a simple shorthand to create function templates-
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-comment-delimiter">// </span><span class="org-comment">This is a shorthand to the template definition below</span>
  <span class="org-keyword">auto</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">a</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> a + b;
  <span class="org-rainbow-delimiters-depth-1">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">The above is the shorthand to this</span>
  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-type">U</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-type">audo</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">a</span>, <span class="org-type">U</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
          <span class="org-keyword">return</span> a + b;
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org16d1f58" class="outline-3">
<h3 id="org16d1f58"><span class="section-number-3">17.4.</span> Non-type Template Parameters</h3>
<div class="outline-text-3" id="text-17-4">
<ul class="org-ul">
<li>A template parameter used to represent a <code>constexpr</code> value.</li>
<li>The following types are accepted as template parameters-
<ol class="org-ol">
<li>Integral types</li>
<li>Enumeration type</li>
<li>Floating Point type (since C++20)</li>
<li>Literal class types (since C++20)</li>
<li>Etc&#x2026;</li>
</ol></li>
<li>From C++17 onwards, you can use the <code>auto</code> keyword to automatically let the compiler deduce the non-type template parameter from the template argument.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span> <span class="org-variable-name">N</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; N &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  print<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf47d43e" class="outline-2">
<h2 id="orgf47d43e"><span class="section-number-2">18.</span> References</h2>
<div class="outline-text-2" id="text-18">
</div>
<div id="outline-container-orgac577f0" class="outline-3">
<h3 id="orgac577f0"><span class="section-number-3">18.1.</span> Lvalue and Rvalue Expressions</h3>
<div class="outline-text-3" id="text-18-1">
<ul class="org-ul">
<li>Rvalue expressions are expressions which evaluate to a value.</li>
<li>Lvalue expressions are expressions which evaluate to identifiable objects.</li>
</ul>
<blockquote>
<p>
If you&rsquo;re not sure if an expression is an lvalue or not, remember that all lvalues can be referenced using the <code>&amp;</code> operator while rvalues can not.
For example, <code>&amp;x</code>, where <code>x</code> is a variable (something like <code>&amp;5</code> won&rsquo;t work since 5 is an rvalue expression).
</p>
</blockquote>
<ul class="org-ul">
<li>Lvalue expressions are implicitly converted to rvalue expressions when they are provided in places where rvalues were expected.</li>
<li>Lvalues are of two types, modifiable (non-const) and non-modifiable (<code>const</code>).</li>
<li>C-style string literalls are rvalues.</li>
</ul>
</div>
</div>
<div id="outline-container-org544bd1b" class="outline-3">
<h3 id="org544bd1b"><span class="section-number-3">18.2.</span> Lvalue References</h3>
<div class="outline-text-3" id="text-18-2">
<ul class="org-ul">
<li>An lvalue reference acts as an alias for an existing lvalue.</li>
<li><p>
It is declared using the <code>&amp;</code> operator
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span class="org-type">int</span> <span class="org-comment-delimiter">// </span><span class="org-comment">int type</span>
  <span class="org-type">int</span>&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">lvalue reference to an int</span>
  <span class="org-type">double</span>&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">lvalue reference to a double</span>
</pre>
</div></li>
<li>We can create lvalue reference variables like this</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">referenceToAge</span> <span class="org-rainbow-delimiters-depth-1">{</span>age<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>References <i>must</i> always be initialized.</li>
<li>Once initialized, a reference can not be changed to refer to another object.</li>
<li>References are not objects in C++. They aren&rsquo;t required to be stored in memory. The compiler might also replace all occurances of the reference with the referent to optimize.</li>
<li>The above point is the reason why you can <i>not</i> have references to references in C++.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">ref</span> <span class="org-rainbow-delimiters-depth-1">{</span>x<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">reference to x</span>
<span class="org-type">int</span>&amp; <span class="org-variable-name">ref2</span> <span class="org-rainbow-delimiters-depth-1">{</span>ref<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this will work because it's NOT a reference to ref, it's a reference to x</span>
</pre>
</div>
<ul class="org-ul">
<li>Lvalue references can not bind to non-modifiable lvalues (non-const).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">ref</span> <span class="org-rainbow-delimiters-depth-1">{</span>x<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">not allowed</span>
</pre>
</div>
<ul class="org-ul">
<li>Type deductions using the <code>auto</code> keyword will drop references.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-1">{</span>x<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">reference to x</span>

<span class="org-keyword">auto</span> <span class="org-variable-name">z</span> <span class="org-rainbow-delimiters-depth-1">{</span>y<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">z is of type int, not int&amp;</span>
<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">z2</span> <span class="org-rainbow-delimiters-depth-1">{</span>y<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">z2 is of type int&amp;</span>
</pre>
</div>
<ul class="org-ul">
<li>Type deductions using <code>auto</code> will drop references first and only then it will drop top-level consts.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-function-name">getConstRef</span><span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">some function that returns a const reference</span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">ref1</span><span class="org-rainbow-delimiters-depth-2">{</span> getConstRef<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span>;        <span class="org-comment-delimiter">// </span><span class="org-comment">std::string (reference and top-level const dropped)</span>
    <span class="org-keyword">const</span> <span class="org-keyword">auto</span> <span class="org-variable-name">ref2</span><span class="org-rainbow-delimiters-depth-2">{</span> getConstRef<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string (reference dropped, const reapplied)</span>
    <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">ref3</span><span class="org-rainbow-delimiters-depth-2">{</span> getConstRef<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string&amp; (reference reapplied, low-level const not dropped)</span>
    <span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">ref4</span><span class="org-rainbow-delimiters-depth-2">{</span> getConstRef<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string&amp; (reference and const reapplied)</span>
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org1765341" class="outline-3">
<h3 id="org1765341"><span class="section-number-3">18.3.</span> Dangling References</h3>
<div class="outline-text-3" id="text-18-3">
<ul class="org-ul">
<li>When the object that a reference refers to is destroyed, the reference becomes a dangling reference.</li>
</ul>
</div>
</div>
<div id="outline-container-org2520f6b" class="outline-3">
<h3 id="org2520f6b"><span class="section-number-3">18.4.</span> Lvalue references to const</h3>
<div class="outline-text-3" id="text-18-4">
<ul class="org-ul">
<li>To make lvalue references bind to non-modifiable lvalues, use the <code>const</code> keyword.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">ref</span> <span class="org-rainbow-delimiters-depth-1">{</span>x<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">allowed</span>

<span class="org-type">int</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">20</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">ref2</span> <span class="org-rainbow-delimiters-depth-1">{</span>y<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">allowed, but ref2 can not be used to modify y</span>
</pre>
</div>

<blockquote>
<p>
Always use lvalue references to const when you don&rsquo;t need to modify the referent.
</p>
</blockquote>
<ul class="org-ul">
<li><p>
Lvalue references to const can also bind to rvalues.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">ref</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">allowed</span>
</pre>
</div></li>
<li>In the above example, a temporary object will be created to store the value 5 and the reference will bind to that temporary object.</li>
<li>This will increase the lifetime of the temporary object to the lifetime of the reference.</li>
</ul>
</div>
</div>
<div id="outline-container-orge1e3b2d" class="outline-3">
<h3 id="orge1e3b2d"><span class="section-number-3">18.5.</span> Pass Values by Reference To Functions</h3>
<div class="outline-text-3" id="text-18-5">
<ul class="org-ul">
<li>Reduces the overhead of copying large objects.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">void</span> <span class="org-function-name">hello</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; name &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Hello World"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  hello<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>
As a rule of thumb, pass fundamental types by value and class (or struct) types by references.
Other common types to pass by value: enumerated types and std::string<sub>view</sub>.
Other common types to pass by (const) reference: std::string, std::array, and std::vector.
</p>
</blockquote>
<ul class="org-ul">
<li>For objects that are cheap to copy, the cost of copying is similar to the cost of binding, so we favor pass by value so the code generated will be faster.</li>
<li>For objects that are expensive to copy, the cost of the copy dominates, so we favor pass by (const) reference to avoid making a copy.</li>
<li><code>std::string_view</code> is better than <code>std::string&amp;</code> because when passing different types of strings (c-style string literals, string<sub>view</sub>, string), the <code>std::string_view</code> will be able to reference all those types easily, while passing types other than <code>std::string</code> to a <code>std::string&amp;</code> will require the compiler to make a temporary <code>std::string</code> object (by implicit conversion or copy).</li>
</ul>
</div>
<div id="outline-container-org3dabb43" class="outline-4">
<h4 id="org3dabb43"><span class="section-number-4">18.5.1.</span> </h4>
</div>
</div>
<div id="outline-container-org4e8fd2e" class="outline-3">
<h3 id="org4e8fd2e"><span class="section-number-3">18.6.</span> Return by Reference</h3>
<div class="outline-text-3" id="text-18-6">
<ul class="org-ul">
<li>When returning values from a function, a copy is returned.</li>
<li>This may be expensive for class types.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-comment-delimiter">// </span><span class="org-comment">notice the ampersand (&amp;) in the return type</span>
<span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">20</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">destroyed at the end of the program</span>
  <span class="org-keyword">return</span> age;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; foo<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<blockquote>
<p>
Avoid returning non-const static values as references.
</p>
</blockquote>
<ul class="org-ul">
<li>Initializing a reference returned by a function to a non reference variable will make a copy of the return value which defeats the entire purpose of returning a reference.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">20</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> age;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{</span>foo<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">BAD: Defeats the purpose of returning reference from foo()</span>
  <span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">age2</span> <span class="org-rainbow-delimiters-depth-2">{</span>foo<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">GOOD</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org143a901" class="outline-3">
<h3 id="org143a901"><span class="section-number-3">18.7.</span> In-Out Parameters</h3>
<div class="outline-text-3" id="text-18-7">
<ul class="org-ul">
<li>Parameters which are used to receive input from the function caller are called in parameters.</li>
<li>Parameters which are used to send output to the function caller are called out parameters (for example, references and pointers which are used to modify the original object from inside the function).</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb5608e3" class="outline-2">
<h2 id="orgb5608e3"><span class="section-number-2">19.</span> Pointers</h2>
<div class="outline-text-2" id="text-19">
<ul class="org-ul">
<li>Always initialize your pointers, for example, <code>int* a{&amp;x};</code>.</li>
<li>Unlike references, pointers <i>are</i> objects and they require space in memory to exist.</li>
<li>References are safer than pointers (which are inherently dangerous).</li>
<li>The size of a pointer depends on the architecture the program&rsquo;s being compiled for. On a 32-bit machine, a pointer will be 32 bit in size and 64bits on a 64-bit machine.</li>
</ul>
</div>
<div id="outline-container-org2b22caf" class="outline-3">
<h3 id="org2b22caf"><span class="section-number-3">19.1.</span> Dangling Pointers</h3>
<div class="outline-text-3" id="text-19-1">
<ul class="org-ul">
<li>Pointers which store invalid addresses are called dangling pointers.</li>
<li>Dereferencing such pointers leads to undefined behaviour.</li>
</ul>
</div>
</div>
<div id="outline-container-org9e471d9" class="outline-3">
<h3 id="org9e471d9"><span class="section-number-3">19.2.</span> Null Pointers</h3>
<div class="outline-text-3" id="text-19-2">
<ul class="org-ul">
<li>Can be initialized using direct list initialization like this- <code>int* ptr {};</code></li>
<li>They don&rsquo;t point to any address.</li>
<li>Can later be assigned an address.</li>
<li>We can use the <code>nullptr</code> <i>literal</i> to initialize a null pointer explicitly- <code>int* ptr {nullptr};</code></li>
<li><code>nullptr</code> has the type <code>std::nullptr_t</code>. So whenever nullptr is used to initialize a pointer variable, it is implicitly converted from <code>std::nullptr_t</code> to the required type.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span>* <span class="org-variable-name">ptr</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">can initialize using nullptr</span>
  <span class="org-type">int</span>* <span class="org-variable-name">anotherPtr</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

  anotherPtr = <span class="org-constant">nullptr</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">can also assign to nullptr literal later</span>

  foo<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">can also pass nullptr literal to functions</span>
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>ptr == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"No"</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">null pointers (nullptr) are implicitly converted to boolean value FALSE and pointers that hold addresses to TRUE</span>
  <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"The pointer, the pointer is real"</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Dereferencing a null pointer also results in undefined behaviour.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd01bac3" class="outline-3">
<h3 id="orgd01bac3"><span class="section-number-3">19.3.</span> Pointer to a Const</h3>
<div class="outline-text-3" id="text-19-3">
<ul class="org-ul">
<li>You can not assign a non-const pointer to a const variable.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>* <span class="org-variable-name">agePtr</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;age<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">compile error!!</span>

<span class="org-keyword">const</span> <span class="org-type">int</span>* <span class="org-variable-name">agePtr2</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;age<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will work!</span>
agePtr2 = <span class="org-rainbow-delimiters-depth-1">{</span>&amp;someOtherVariable<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">will still work!</span>
</pre>
</div>
<ul class="org-ul">
<li>A <b>pointer to a const</b> is <b>not</b> a const itself, so you can change the address it is pointing to.</li>
<li>A <b>pointer to a const</b>, when pointing to a non-const variable will not allow you to modify the value at the address it is pointing to.</li>
</ul>
</div>
</div>
<div id="outline-container-org942fdc4" class="outline-3">
<h3 id="org942fdc4"><span class="section-number-3">19.4.</span> Const Pointers</h3>
<div class="outline-text-3" id="text-19-4">
<ul class="org-ul">
<li>This is different from a <b>pointer to a const</b>.</li>
<li>A const pointer is a pointer whose address can not be changed once initialized.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">int</span>* <span class="org-keyword">const</span> <span class="org-variable-name">agePtr</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;age<span class="org-rainbow-delimiters-depth-1">}</span>;

agePtr = <span class="org-rainbow-delimiters-depth-1">{</span>&amp;someOtherVariable<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">NOT ALLOWED</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orge23bd6e" class="outline-3">
<h3 id="orge23bd6e"><span class="section-number-3">19.5.</span> Const Pointer to a Const Variable</h3>
<div class="outline-text-3" id="text-19-5">
<ul class="org-ul">
<li>The combination of both the above!</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">const</span> <span class="org-type">int</span>* <span class="org-keyword">const</span> <span class="org-variable-name">agePtr</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;age<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>Just like normal <b>pointer to const variables</b>, the referents don&rsquo;t have to be const.</li>
</ul>
</div>
</div>
<div id="outline-container-org08f71d3" class="outline-3">
<h3 id="org08f71d3"><span class="section-number-3">19.6.</span> Passing Values to Functions By Address</h3>
<div class="outline-text-3" id="text-19-6">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>* <span class="org-variable-name">num</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; *num &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  foo<span class="org-rainbow-delimiters-depth-2">(</span>&amp;age<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>
Prefer using references instead of pointers wherever possible.
</p>
</blockquote>
<ul class="org-ul">
<li>Passing by address copies the address from the caller to the function.</li>
</ul>
</div>
</div>
<div id="outline-container-org5584fc4" class="outline-3">
<h3 id="org5584fc4"><span class="section-number-3">19.7.</span> Setting Optional Parameters in Functions</h3>
<div class="outline-text-3" id="text-19-7">
<ul class="org-ul">
<li>We can use <code>nullptr</code> to set optional parameters in functions.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span>* <span class="org-variable-name">bar</span>=<span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>bar<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::cout &lt;&lt; *bar;
  <span class="org-keyword">else</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"No"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Function overloading is a better way to achive the same result.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">bar</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; bar;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"No"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd432aba" class="outline-3">
<h3 id="orgd432aba"><span class="section-number-3">19.8.</span> Top Level and Low Level Consts</h3>
<div class="outline-text-3" id="text-19-8">
<ul class="org-ul">
<li>Consts that apply to the object itself are called top level consts. For example, <code>const int x {5};</code>.</li>
<li>Consts that apply to the reference or pointer to the object are called low level consts. For example, <code>int const* ptr {&amp;x};</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">const</span> <span class="org-type">int</span>* <span class="org-keyword">const</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;z<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">the left const is low level, the right const is top level</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org6f1732a" class="outline-3">
<h3 id="org6f1732a"><span class="section-number-3">19.9.</span> Auto and Pointers</h3>
<div class="outline-text-3" id="text-19-9">
</div>
<div id="outline-container-orgf6acd4e" class="outline-4">
<h4 id="orgf6acd4e"><span class="section-number-4">19.9.1.</span> <span class="todo TODO">TODO</span> Read chapter 12.14 again!</h4>
<div class="outline-text-4" id="text-19-9-1">
<ul class="org-ul">
<li>When using the auto keyword, the pointer type is not dropped, only top level consts are dropped.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-1">{}</span>;
<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-keyword">const</span> <span class="org-variable-name">ptr</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;s<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">statement // final type deduced</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">ptr1</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string*</span>
<span class="org-keyword">auto</span>* <span class="org-variable-name">ptr2</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string*</span>

<span class="org-keyword">const</span> <span class="org-keyword">auto</span> <span class="org-variable-name">ptr3</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string* const</span>
<span class="org-keyword">auto</span> <span class="org-keyword">const</span> <span class="org-variable-name">ptr4</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string* const</span>

<span class="org-keyword">auto</span>* <span class="org-keyword">const</span> <span class="org-variable-name">ptr5</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string* const</span>
<span class="org-keyword">const</span> <span class="org-keyword">auto</span>* <span class="org-variable-name">ptr6</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string*</span>

<span class="org-keyword">const</span> <span class="org-keyword">auto</span> <span class="org-keyword">const</span> <span class="org-variable-name">ptr7</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">error, const is used twice</span>
<span class="org-keyword">const</span> <span class="org-keyword">auto</span>* <span class="org-keyword">const</span> <span class="org-variable-name">ptr8</span> <span class="org-rainbow-delimiters-depth-1">{</span>ptr<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">const std::string* const</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd3d706e" class="outline-2">
<h2 id="orgd3d706e"><span class="section-number-2">20.</span> User Defined Types</h2>
<div class="outline-text-2" id="text-20">
<p>
These include
</p>
<ol class="org-ol">
<li>Enumerated Types</li>
<li>Class Types
<ol class="org-ol">
<li>Structs</li>
<li>Classes</li>
<li>Unions</li>
</ol></li>
</ol>
<blockquote>
<p>

</p>

<p>
Compilers need to see the full definition of user defined types. So, try to make a separate header file with the same name as the type and include it wherever you need to use it.
</p>
</blockquote>
<p>
The C++ language standard defines a user-defined type as any class or enumerated type defined by you, the standard library or the implementation. This means that even <code>std::string</code> is considered a user defined type.
</p>
</div>
<div id="outline-container-org495cfda" class="outline-3">
<h3 id="org495cfda"><span class="section-number-3">20.1.</span> Enumeration Types</h3>
<div class="outline-text-3" id="text-20-1">
</div>
<div id="outline-container-orgd214acc" class="outline-4">
<h4 id="orgd214acc"><span class="section-number-4">20.1.1.</span> Unscoped Enumerations</h4>
<div class="outline-text-4" id="text-20-1-1">
<ul class="org-ul">
<li>They are defined using the <code>enum</code> keyword.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span> = <span class="org-highlight-numbers-number">5</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 5</span>
  <span class="org-variable-name">green</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 6</span>
  <span class="org-variable-name">blue</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 7</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Now, we can use Color as a data type</span>
  <span class="org-type">Color</span> <span class="org-variable-name">apple</span> <span class="org-rainbow-delimiters-depth-2">{</span>red<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">Color</span> <span class="org-variable-name">shirt</span> <span class="org-rainbow-delimiters-depth-2">{</span>blue<span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-type">Color</span> <span class="org-variable-name">ball</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">ERROR because 2 is not a part of the enum Color</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">namespace</span> <span class="org-constant">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">enum</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-variable-name">red</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 0</span>
    <span class="org-variable-name">green</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 1</span>
    <span class="org-variable-name">blue</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">assigned 2</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">Color</span>::<span class="org-type">Color</span> <span class="org-variable-name">apple</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">Color</span>::red<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">notice the data type and the enumerator</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="org3958f48"></a>Enumeration Size or Underlying Type<br />
<div class="outline-text-5" id="text-20-1-1-1">
<ul class="org-ul">
<li>This is the specific type used to represent the integral values held by the enumerators.</li>
<li>Default type depends on the compiler but is mostly <code>int</code>.</li>
<li>You might want to use a different type to save bandwidth or any other reason-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-type">Color</span> : <span class="org-type">std::int8_t</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span>,
  <span class="org-variable-name">green</span>,
  <span class="org-variable-name">blue</span>,
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Do this only when necessary.</li>
<li>If we specify the type like this, we can <b>list initialize</b> the variable using integer literals.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-type">Color</span> : <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span>,
  <span class="org-variable-name">green</span>,
  <span class="org-variable-name">blue</span>,
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Color</span> <span class="org-variable-name">apple</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">okay, list initialization is allowed if type is specified.</span>
  <span class="org-type">Color</span> <span class="org-variable-name">shirt</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">compile error, copy initialization not allowed with integer literals</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org73f2aaa" class="outline-4">
<h4 id="org73f2aaa"><span class="section-number-4">20.1.2.</span> Scoped Enumerations</h4>
<div class="outline-text-4" id="text-20-1-2">
<ul class="org-ul">
<li>Similar to unscoped but they prevent the following two things-
<ol class="org-ol">
<li>They don&rsquo;t implicitly convert to integers</li>
<li>They are only placed in the scope region of the enumeration</li>
</ol></li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span>,
  <span class="org-variable-name">green</span>,
  <span class="org-variable-name">blue</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Color</span> <span class="org-variable-name">apple</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">Color</span>::red<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">Color</span> <span class="org-variable-name">shirt</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">Color</span>::blue<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Since they don&rsquo;t implicitly convert to integers, you can not print them onto the screen using <code>std::cout</code>. You can use C++23&rsquo;s <code>std::to_underlying(Color::red)</code> or a normal static conversion to print them.</li>
<li>From C++20 onwards, we can do the following-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">red</span>,
  <span class="org-variable-name">green</span>,
  <span class="org-variable-name">blue</span>,
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-type">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">using</span> <span class="org-keyword">enum</span> Color;
  <span class="org-type">Color</span> <span class="org-variable-name">car</span> <span class="org-rainbow-delimiters-depth-2">{</span>red<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no need to use the scope resolution operator ::</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org42eb688" class="outline-3">
<h3 id="org42eb688"><span class="section-number-3">20.2.</span> Class Types</h3>
<div class="outline-text-3" id="text-20-2">
</div>
<div id="outline-container-org15479c7" class="outline-4">
<h4 id="org15479c7"><span class="section-number-4">20.2.1.</span> Structs</h4>
<div class="outline-text-4" id="text-20-2-1">
<ul class="org-ul">
<li>These are program defined types.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">double</span> <span class="org-variable-name">wage</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">no need to use "struct Employee john" unlike C</span>
  <span class="org-type">Employee</span> <span class="org-variable-name">john</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>The variables inside a struct are called data members.</li>
<li>Structs are of aggregate type meaning they store multiple data members (these include C-style arrays, structs, std::array, etc).</li>
<li>Structs require aggregate initialization like this-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">Employee</span> <span class="org-variable-name">john</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">24</span>, <span class="org-highlight-numbers-number">50000.0</span><span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">direct list initialization (preferred)</span>
<span class="org-type">Employee</span> <span class="org-variable-name">doe</span> = <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">24</span>, <span class="org-highlight-numbers-number">60000.0</span><span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">copy list initialization</span>
</pre>
</div>
<ul class="org-ul">
<li>If we leave the list empty (<code>Employee john {};</code>) when initializing a struct type, it will get value initialized (0 for integral types, &ldquo;&rdquo; for string etc..).</li>
</ul>
<blockquote>
<p>

</p>

<p>
An type is NOT considered aggregate if it has any of the following-
</p>
<ul class="org-ul">
<li>User declared constructor</li>
<li>Private or protected non-static data members</li>
<li>Virtual functions</li>
</ul>
</blockquote>
</div>
<ol class="org-ol">
<li><a id="org16d0030"></a>Designated Initializers<br />
<div class="outline-text-5" id="text-20-2-1-1">
<ul class="org-ul">
<li>Only for C++20 and above.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">double</span> <span class="org-variable-name">wage</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-type">Employee</span> <span class="org-variable-name">tenma</span> <span class="org-rainbow-delimiters-depth-2">{</span> .id<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-3">}</span>, .age<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">24</span><span class="org-rainbow-delimiters-depth-3">}</span>, .wage<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">60000.0</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">ok</span>
  <span class="org-type">Employee</span> <span class="org-variable-name">johan</span> <span class="org-rainbow-delimiters-depth-2">{</span> .id<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-3">}</span>, .wage<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">60000.0</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">ok, age is value initialized (0)</span>
  <span class="org-type">Employee</span> <span class="org-variable-name">anna</span> <span class="org-rainbow-delimiters-depth-2">{</span> .wage<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">60000.0</span><span class="org-rainbow-delimiters-depth-3">}</span>, .id<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">error, order does not match</span>
  <span class="org-constant">std</span>::cout &lt;&lt; john.wage &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Do not use designated initializers to prevent clutter. Use the normal way and if you need to add new data members, add them to the end so order won&rsquo;t mix up.
</p>
</blockquote>
</div>
</li>
<li><a id="org7830b77"></a>Designated Assignment<br />
<div class="outline-text-5" id="text-20-2-1-2">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">double</span> <span class="org-variable-name">wage</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-type">Employee</span> <span class="org-variable-name">tenma</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  tenma = <span class="org-rainbow-delimiters-depth-2">{</span>.id = <span class="org-highlight-numbers-number">1</span>, .age = <span class="org-highlight-numbers-number">32</span>, .wage = <span class="org-highlight-numbers-number">50000.0</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; john.wage &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org7a211ce"></a>Default Member Initialization<br />
<div class="outline-text-5" id="text-20-2-1-3">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Something</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">first</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">bad</span>
  <span class="org-type">int</span> <span class="org-variable-name">second</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">0 initialized</span>
  <span class="org-type">int</span> <span class="org-variable-name">third</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">default value 5</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Something</span> <span class="org-variable-name">thing</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">first is value initialized to 0, second has default member 0, third is 5</span>
  <span class="org-constant">std</span>::cout &lt;&lt; thing.first &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-type">Something</span> <span class="org-variable-name">anotherThing</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">not initialized (bad)</span>
  <span class="org-constant">std</span>::cout &lt;&lt; anotherThing.first &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-comment-delimiter">// </span><span class="org-comment">garbage value since it's not value initialized</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Always provide a default value to each member of structs.
</p>
</blockquote>
</div>
</li>
<li><a id="org5b1b07f"></a>Passing/Returning Structs From/To Functions<br />
<div class="outline-text-5" id="text-20-2-1-4">
<ul class="org-ul">
<li>Always try to pass structs by references or pointers to avoid making copies.</li>
<li>When passing by reference, you can access properties by using <code>.</code> like <code>thing.first</code>.</li>
<li>When passing by pointers, you have to access properties by using <code>-&gt;</code> like <code>thing-&gt;first</code>.</li>
<li>When returning, it is not necessary to create a temporary object and then return it.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">z</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">It returns point with default initialized members</span>
<span class="org-type">Point</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">You can also do something like this</span>
  <span class="org-comment-delimiter">/*</span>
<span class="org-comment">   * return Point {}; </span>
<span class="org-comment">   * return {1, 2, 3}; </span>
<span class="org-comment-delimiter">   */</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="orgfa03156"></a>Nested Structs<br />
<div class="outline-text-5" id="text-20-2-1-5">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">Company</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">struct</span> <span class="org-type">CEO</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
    <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">numberOfEmployees</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">CEO</span> <span class="org-variable-name">companyCEO</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Company</span> <span class="org-variable-name">myCompany</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">50000</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">0</span>, <span class="org-highlight-numbers-number">20</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; myCompany.companyCEO.age &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="orge06da26"></a>Size of Structs and Padding<br />
<div class="outline-text-5" id="text-20-2-1-6">
<ul class="org-ul">
<li>The size of a struct is <i>not</i> always the sum of sizes of its data members.</li>
<li>The compiler can add certain gaps (called padding) in the struct for performance reasons. For example, if the sum of size is 14 bytes, it will add gaps such that the size of the actual struct will be 16 bytes (2x8).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">size of this struct is 12</span>
<span class="org-keyword">struct</span> <span class="org-type">One</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">short</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">2 bytes of padding added to make the size 4 bytes</span>
  <span class="org-type">int</span> <span class="org-variable-name">b</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">short</span> <span class="org-variable-name">c</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">2 bytes of more padding added</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">size of this struct is 8</span>
<span class="org-keyword">struct</span> <span class="org-type">Two</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">b</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no padding</span>
  <span class="org-type">short</span> <span class="org-variable-name">c</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no padding</span>
  <span class="org-type">short</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no padding</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<blockquote>
<p>

</p>

<p>
Always define data members of structs in decreasing order of their size to avoid padding as much as possible.
</p>
</blockquote>
</div>
</li>
</ol>
</div>
<div id="outline-container-org17615f4" class="outline-4">
<h4 id="org17615f4"><span class="section-number-4">20.2.2.</span> Class Templates on Structs</h4>
<div class="outline-text-4" id="text-20-2-2">
<ul class="org-ul">
<li>Just like function templates are used to generate function definitions, class templates are used to generate class types (structs, classes, etc).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">T</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">T</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">coords</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">0</span>,<span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; coords.x &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; coords.y &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>We can <b>not</b> overload structs for different data types. The compiler will see them just like a redefinition of the struct.</li>
<li>We can make functions for these template classes like this-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">T</span> <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">T</span> <span class="org-variable-name">y</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">T</span> <span class="org-function-name">getDistanceFromOrigin</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">pt</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::sqrt<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::pow<span class="org-rainbow-delimiters-depth-4">(</span>pt.x, <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-4">)</span> + <span class="org-constant">std</span>::pow<span class="org-rainbow-delimiters-depth-4">(</span>pt.y, <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">template argument will be deduced automatically</span>
  <span class="org-constant">std</span>::cout &lt;&lt; getDistanceFromOrigin<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="orgc763c40"></a><code>std::pair</code><br />
<div class="outline-text-5" id="text-20-2-2-1">
<ul class="org-ul">
<li>Working with pairs of data is very common.</li>
<li>The C++ standard library has a built-in class template for a pair type with <code>first</code> and <code>second</code> as the data members.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">utility</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">pair</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">3.4</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; a.first &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-constant">std</span>::cout &lt;&lt; a.second &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Favour using this instead of writing your own &ldquo;pair&rdquo; class template.</li>
</ul>
</div>
</li>
<li><a id="org8ddb410"></a>CTAD (C++17)<br />
<div class="outline-text-5" id="text-20-2-2-2">
<ul class="org-ul">
<li>Class Template Argument Deduction</li>
<li>Starting from C++17, the compiler can deduce the types of template arguments on its own when instantiating objects of the class templates.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">T</span> <span class="org-variable-name">x</span>;
  <span class="org-type">T</span> <span class="org-variable-name">y</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Point</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>The above program won&rsquo;t work with C++17 but will work on C++20 because prior to C++20, you had to specify a &ldquo;deduction guide&rdquo; to the compiler so that it knows how to deduce the type.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">T</span> <span class="org-variable-name">x</span>;
  <span class="org-type">T</span> <span class="org-variable-name">y</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Deduction guide for C++17</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">We are simply saying that if it finds a declaration of Point with two arguments of type T and T</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">it should deduce the type to be of Pair&lt;T&gt;</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">Point</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span>, <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Point</span> <span class="org-variable-name">a</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org69fed09" class="outline-2">
<h2 id="org69fed09"><span class="section-number-2">21.</span> Object Oriented Programming</h2>
<div class="outline-text-2" id="text-21">
</div>
<div id="outline-container-org1a1cea4" class="outline-3">
<h3 id="org1a1cea4"><span class="section-number-3">21.1.</span> Classes</h3>
<div class="outline-text-3" id="text-21-1">
</div>
<div id="outline-container-orgdbe380f" class="outline-4">
<h4 id="orgdbe380f"><span class="section-number-4">21.1.1.</span> Introduction</h4>
<div class="outline-text-4" id="text-21-1-1">
<ul class="org-ul">
<li>A class is a program-defined type which can have member variables of different types and member functions.</li>
<li>Example definition of a class with member variables-</li>
<li>Structs and classes are almost identical in C++. Any example written using classes can also be written using structs and vice-versa.</li>
<li>Structs have all the capabilities that classes have in C++ (not in C though), so you may use the one you like or go with the convention of using classes.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">age</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">double</span> <span class="org-variable-name">wage</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orge46200f" class="outline-4">
<h4 id="orge46200f"><span class="section-number-4">21.1.2.</span> Member Functions</h4>
<div class="outline-text-4" id="text-21-1-2">
<ul class="org-ul">
<li>Functions defined inside class types are called member functions.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Date</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">day</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">month</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">year</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; day &lt;&lt; <span class="org-string">'/'</span> &lt;&lt; month &lt;&lt; <span class="org-string">'/'</span> &lt;&lt; year &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Date</span> <span class="org-variable-name">today</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">23</span>,<span class="org-highlight-numbers-number">3</span>,<span class="org-highlight-numbers-number">2024</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  today.print<span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Member functions can be written in any order in a class type.</li>
<li>Member functions can also be overloaded as long as they can be differentiated.</li>
<li>Defining members functions inside structs should be avoided because it makes them a non-agregate, and that&rsquo;s why we use classes instead.</li>
</ul>
</div>
</div>
<div id="outline-container-org2b1a892" class="outline-4">
<h4 id="org2b1a892"><span class="section-number-4">21.1.3.</span> Const Class Type Objects</h4>
<div class="outline-text-4" id="text-21-1-3">
<ul class="org-ul">
<li>Class type objects can be initialized with the <code>const</code> keyword.</li>
<li>They can not be left uninitialized.</li>
<li>No attempt to modify their properties is entertained.</li>
<li>Const objects are also not allowed to call non-const member functions-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Test</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"test"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">print2</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"test2"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    ++id; <span class="org-comment-delimiter">// </span><span class="org-comment">error, const member functions can not modify members</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">const</span> <span class="org-type">Test</span> <span class="org-variable-name">t</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  t.id = <span class="org-highlight-numbers-number">1</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">error</span>
  t.print<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">error again</span>
  t.print2<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">ok</span>

  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
A function which does not modify the state of an object <i>should</i> absolutely be made <code>const</code> as a good practice.
</p>
</blockquote>
<ul class="org-ul">
<li>You can overload the same member function with the exact same definition by adding a variant without the <code>const</code> keyword and one with the <code>const</code> keyword.</li>
</ul>
</div>
</div>
<div id="outline-container-org8ea7b51" class="outline-4">
<h4 id="org8ea7b51"><span class="section-number-4">21.1.4.</span> Access Levels</h4>
<div class="outline-text-4" id="text-21-1-4">
<p>
C++ classes have three access levels: public, private and protected.
</p>
<ul class="org-ul">
<li>Members of struct are public by default.</li>
<li>Members of class are private by default.</li>
<li>We can <b>not</b> use aggregate initialization for classes because their members are private by default!</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgca70df8"></a>Public<br />
<div class="outline-text-5" id="text-21-1-4-1">
<p>
Public members of a class type can be accessed by anyone in the scope.
We can set access level of data members using the <b>access specifier</b> <code>public:</code>.
</p>

<pre class="example">
2004-6-5
</pre>
</div>
</li>
<li><a id="org4f18e6c"></a>Private<br />
<div class="outline-text-5" id="text-21-1-4-2">
<p>
Private members of a class type can only be accessed by other members of the same class.
</p>
<blockquote>
<p>

</p>

<p>
It is a good practice to prefix private data members with an <code>m_</code> like <code>m_age</code>.
</p>
</blockquote>
<p>
We can set the access level using <code>private:</code>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">class</span> <span class="org-type">Date</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">public</span>:
  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; m_year &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; m_month &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; m_day &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-keyword">private</span>:
  <span class="org-type">int</span> <span class="org-variable-name">m_year</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">2004</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_month</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">6</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_day</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;



<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Date</span> <span class="org-variable-name">date</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  date.print<span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<blockquote>
<p>

</p>

<p>
Best Practice: Classes should generally make member variables private and member functions public.
Structs should avoid using access specifiers and all members should be made public.
</p>
</blockquote>
<ul class="org-ul">
<li>Private members can be accessed by other OBJECTS of the same class too!</li>
</ul>
</div>
</li>
<li><a id="orgc00765e"></a>Access Functions<br />
<div class="outline-text-5" id="text-21-1-4-3">
<ul class="org-ul">
<li>These are trivial public member functions whose job is to retreive or change the value of a private member variable.</li>
<li>These come in two flavours: getters and setters.</li>
<li>Getters are usually made const so they can be called on both const and non-const objects.</li>
<li>Setters should be non-const.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Date</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-type">int</span> <span class="org-variable-name">m_year</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_month</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_day</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-keyword">public</span>:
  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; m_year &lt;&lt; <span class="org-string">'/'</span> &lt;&lt; m_month &lt;&lt; <span class="org-string">'/'</span> &lt;&lt; m_day &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">int</span> <span class="org-function-name">getYear</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_year; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">setYear</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">year</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> m_year = year; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">int</span> <span class="org-function-name">getMonth</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_month; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">setMonth</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">month</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> m_month = month; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">int</span> <span class="org-function-name">getDay</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_day; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">setDay</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">day</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> m_day = day; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<blockquote>
<p>

</p>

<p>
A member function returning a reference should return a reference of the same type as the data member being returned, to avoid unnecessary conversions. For example, you should <b>not</b> return <code>std::string_view</code> for an <code>std::string</code> because that would require an unnecessary conversion.
</p>
</blockquote>
</div>
</li>
</ol>
</div>
<div id="outline-container-org1154789" class="outline-4">
<h4 id="org1154789"><span class="section-number-4">21.1.5.</span> Encapsulation (Data Hiding)</h4>
<div class="outline-text-4" id="text-21-1-5">
<ul class="org-ul">
<li>The interface of a class type defines how a user interacts with objects of that class type.</li>
<li>An interace composed of public members is sometimes called the <b>public interace</b>.</li>
<li>The <b>implementation</b> consists of the code that actually makes the class behave as intended. It includes the member variables which store data and the <b>body</b> of member functions.</li>
<li>Data hiding is also known as <b>encapsulation</b>.</li>
<li>It is a technique used to enforce the separation of interface and implementation.</li>
<li>It is simply implemented by making member variables private and providing public member functions to manipulate the private members.</li>
<li><b>Class invariants</b> are conditions which <i>must</i> be true throughout the lifetime of an object in order for the object to stay in a valid state.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">consider this example</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the user will have to change the initial if he/she ever changes the name</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">this is called a class invariant (initial must be the first letter of name throughout the program)</span>
<span class="org-keyword">class</span> <span class="org-type">Person</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">public</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"John"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">char</span> <span class="org-variable-name">initial</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">'J'</span><span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>This is one of the biggest reasons why we should use encapsulation.</li>
<li>Data hiding helps provide better error handling by verifying values in the setters.</li>
<li>It also helps us to change the implementation of the underlying member variables without breaking programs using the interface.</li>
</ul>
<blockquote>
<p>

</p>

<p>
If a function can be implemented as a <b>non-member</b> function, consider implementing it as a non-member function. This will make sure-
</p>
<ul class="org-ul">
<li>Interface of your class is smaller.</li>
<li>They are easier to debug.</li>
</ul>
</blockquote>
<blockquote>
<p>

</p>

<p>
Best Practice-
Declare public members first in your class definitions followed by private members. This is because any user looking at your class is only interested in the interface.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org0521d21" class="outline-4">
<h4 id="org0521d21"><span class="section-number-4">21.1.6.</span> Constructors</h4>
<div class="outline-text-4" id="text-21-1-6">
<ul class="org-ul">
<li>Non-aggregate types (such as structs with private members or class types) can not be initialized using aggregate initialization.</li>
<li>One of the reasons is that, for data hiding, we don&rsquo;t want the user to worry about the implementation of the data members.</li>
<li>So, if the user had to initialize using aggregate initialization, then the user would need to know the order in which members were defined.</li>
<li>Constructors are functions used to initialize data members and do optional things like opening databases etc upon the creation of a class type <i>object</i>.</li>
<li>First, the object is created and then the matching constructor is called. If the constructor function is not found, an error is raised by the compiler.</li>
<li>Constructors can also be overloaded since they&rsquo;re just functions.</li>
<li>One class type can only have one <i>default</i> constructor (a constructor which does not take any parameters).</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orge4108cc"></a>Naming Constructors<br />
<div class="outline-text-5" id="text-21-1-6-1">
<ul class="org-ul">
<li>Constructors have special rules which must be followed while naming them.
<ol class="org-ol">
<li>The function must have the same name as that of the class type (with the same case).</li>
<li>The function must <i>not</i> return anything.</li>
</ol></li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string_view</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Student</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_age</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

<span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">this is the constructor function without any return type</span>
  <span class="org-function-name">Student</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">age</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    m_name = name;
    m_age = age;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_name;<span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>m_name = name;<span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">int</span> <span class="org-function-name">getAge</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_age;<span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">setAge</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">age</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>m_age = age;<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Student</span> <span class="org-variable-name">s1</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Prayag Jain"</span>, <span class="org-highlight-numbers-number">20</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; s1.getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="orga61db88"></a>Member Initialization List<br />
<div class="outline-text-5" id="text-21-1-6-2">
<ul class="org-ul">
<li>No need to assign member variables to the arguments passed to the constructor.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Student</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_age</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Student</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">age</span><span class="org-rainbow-delimiters-depth-2">)</span>: m_name <span class="org-rainbow-delimiters-depth-2">{</span>name<span class="org-rainbow-delimiters-depth-2">}</span>, m_age <span class="org-rainbow-delimiters-depth-2">{</span>age<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Initialized successfully"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_name;<span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>m_name = name;<span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">int</span> <span class="org-function-name">getAge</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_age;<span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">setAge</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">age</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>m_age = age;<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Student</span> <span class="org-variable-name">s1</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Prayag Jain"</span>, <span class="org-highlight-numbers-number">20</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; s1.getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org7705204"></a>Implicit Default Constructors<br />
<div class="outline-text-5" id="text-21-1-6-3">
<ul class="org-ul">
<li>If no constructor is provided to a class, an implicit default constructor is created which can be used to initialize objects of the constructor.</li>
<li>The implicit constructor does <i>not</i> take any arguments and is equivalen to-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Student</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">m_age</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-type">char</span> <span class="org-variable-name">m_initial</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; 
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Student</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</li>
<li><a id="org4e82ae6"></a>Explicit Default Constructors<br />
<div class="outline-text-5" id="text-21-1-6-4">
<ul class="org-ul">
<li>In cases when we want to generate a default constructor similar to the implicit one, we can do something like this-</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Student</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">m_age</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-type">char</span> <span class="org-variable-name">m_initial</span> <span class="org-rainbow-delimiters-depth-2">{}</span>; 
  <span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">explicit default constructor (prefer doing this)</span>
    <span class="org-function-name">Student</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">overloaded constructor</span>
    <span class="org-function-name">Student</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">age</span>, <span class="org-type">char</span> <span class="org-variable-name">initial</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_age<span class="org-rainbow-delimiters-depth-2">{</span>age<span class="org-rainbow-delimiters-depth-2">}</span>, m_initial<span class="org-rainbow-delimiters-depth-2">{</span>initial<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</li>
<li><a id="org7c60361"></a>Delegating Constructors<br />
<div class="outline-text-5" id="text-21-1-6-5">
<ul class="org-ul">
<li>In a class type, constructors are allowed to transfer the ability to initialize to another constructor of the same class type.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-type">int</span> <span class="org-variable-name">m_id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

<span class="org-keyword">public</span>:
  <span class="org-function-name">Employee</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">id</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_id<span class="org-rainbow-delimiters-depth-2">{</span>id<span class="org-rainbow-delimiters-depth-2">}</span>, m_name<span class="org-rainbow-delimiters-depth-2">{</span>name<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"initialized"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">delegated to the above function</span>
  <span class="org-function-name">Employee</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> : Employee<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">0</span>, name<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Employee</span> <span class="org-variable-name">e1</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Prayag"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-type">Employee</span> <span class="org-variable-name">e2</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1</span>, <span class="org-string">"Parin"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org2c569ad"></a>Temporary Class Objects<br />
<div class="outline-text-5" id="text-21-1-6-6">
<ul class="org-ul">
<li>We can temporarily create class objects to pass them to functions or use in expressions.</li>
<li>This is useful when you only want to use that object once.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">assume a Ball object exists</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">assume a print function exists</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">temporary ball object passed to function</span>
  print<span class="org-rainbow-delimiters-depth-2">(</span>Ball<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"white"</span>, <span class="org-highlight-numbers-number">5.0</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">implicit conversion to ball object</span>
  print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"white"</span>, <span class="org-highlight-numbers-number">5.0</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</li>
<li><a id="org6d868a4"></a>Copy Constructor<br />
<div class="outline-text-5" id="text-21-1-6-7">
<ul class="org-ul">
<li>Used to initialize an object with an object of the same type.</li>
<li>Implicit copy constructors are created when one is not created explicitly.</li>
<li>You can explicitly create a copy constructor like this-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_id</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>, m_id<span class="org-rainbow-delimiters-depth-2">(</span>id<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"constructor called"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Explicit copy constructor</span>
  <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Employee</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_name<span class="org-rainbow-delimiters-depth-2">(</span>e.m_name<span class="org-rainbow-delimiters-depth-2">)</span>, m_id<span class="org-rainbow-delimiters-depth-2">(</span>e.m_id<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"copy constructor called"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Employee</span> <span class="org-variable-name">alice</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Alice"</span>, <span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">Employee</span> <span class="org-variable-name">bob</span> <span class="org-rainbow-delimiters-depth-2">{</span>alice<span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Calls the copy constructor</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Prefer the implicit copy constructor, but if you do want to create an explicit one, the parameter <i>must</i> be a const lvalue reference. This is because if its passed by value, it would start an infinite chain of calls to the copy constructor (copy constructor is called when passing objects by value).
</p>
</blockquote>
<ul class="org-ul">
<li>We can also tell the compiler to explicitly create a copy constructor for us-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_id</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>, m_id<span class="org-rainbow-delimiters-depth-2">(</span>id<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"constructor called"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Explicit copy constructor</span>
  <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Employee</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">default</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>We can prevent objects from being copied by using the <code>= delete</code> syntax.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_id</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>, m_id<span class="org-rainbow-delimiters-depth-2">(</span>id<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"constructor called"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Copying the object will not be allowed</span>
  <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Employee</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</li>
<li><a id="org2bc70ff"></a>Copy Elision<br />
<div class="outline-text-5" id="text-21-1-6-8">
<ul class="org-ul">
<li>It is an optimization technique used by compilers that allows them to remove unnecessary copying of objects.</li>
<li>When the compiler optimizes away a call to the copy constructor, we say the object has been <i>elided</i>.</li>
<li>The compiler is free to remove unnecessary calls to the copy constructor, <i>even if it has side effects</i>!</li>
<li>This is one of the biggest reasons copy constructors <i>should not</i> have any side effects.</li>
</ul>
</div>
</li>
<li><a id="org0734a18"></a>Converting Constructors<br />
<div class="outline-text-5" id="text-21-1-6-9">
<ul class="org-ul">
<li>All constructors are converting constructors by default.</li>
<li>Constructors are used to determine how to do implicit conversion where a specific class type object was required but something else was provided.</li>
<li>Only one user-defined conversion may be applied to perform an implicit conversion.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string_view</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

<span class="org-keyword">public</span>:
  <span class="org-function-name">Employee</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>, m_id<span class="org-rainbow-delimiters-depth-2">(</span>id<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> : Employee<span class="org-rainbow-delimiters-depth-2">(</span>name, <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

  <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Employee</span>&amp; <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">default</span>;

  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_name;<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">void</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Employee</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; e.getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  getName<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Parin"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">compiler error because "Parin" will first be converted to std::string_view from const char* and that will then be converted to an Employee{} object but only one implicit conversion is allowed (2 here).</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>The <code>explicit</code> keyword can be used to specify that a constructor should <i>not</i> be used as a converting constuctor, hence, disallowing implicit conversions.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Employee</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_id</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

<span class="org-keyword">public</span>:

  <span class="org-comment-delimiter">// </span><span class="org-comment">implicit conversions won't be allowed</span>
  <span class="org-keyword">explicit</span> <span class="org-function-name">Employee</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>, m_id<span class="org-rainbow-delimiters-depth-2">(</span>id<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-keyword">explicit</span> <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> : Employee<span class="org-rainbow-delimiters-depth-2">(</span>name, <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

  <span class="org-function-name">Employee</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Employee</span>&amp; <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">default</span>;

  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_name;<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Make any constructor that accepts a single argument explicit by default. If an implicit conversion between types is both semantically equivalent and performant, you can consider making the constructor non-explicit.
</p>

<p>
Do not make copy or move constructors explicit, as these do not perform conversions.
</p>
</blockquote>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org72c836a" class="outline-2">
<h2 id="org72c836a"><span class="section-number-2">22.</span> More on Classes</h2>
<div class="outline-text-2" id="text-22">
</div>
<div id="outline-container-org2a84f49" class="outline-3">
<h3 id="org2a84f49"><span class="section-number-3">22.1.</span> The <code>this</code> keyword</h3>
<div class="outline-text-3" id="text-22-1">
<ul class="org-ul">
<li>Every member function has an access to a const pointer named <code>this</code>.</li>
<li>This pointer points to the address of the current object.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-type">int</span> <span class="org-variable-name">m_x</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_y</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Point</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span> = <span class="org-highlight-numbers-number">0</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span> = <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_x<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>, m_y<span class="org-rainbow-delimiters-depth-2">(</span>y<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>
  <span class="org-type">int</span> <span class="org-function-name">getX</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-keyword">this</span>-&gt;m_x; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Point</span> <span class="org-variable-name">point</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; point.getX<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgea5e9c4" class="outline-3">
<h3 id="orgea5e9c4"><span class="section-number-3">22.2.</span> Returning <code>*this</code></h3>
<div class="outline-text-3" id="text-22-2">
<ul class="org-ul">
<li>We can return <code>*this</code> keyword in member functions and achieve function chaining!</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Fraction</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-type">int</span> <span class="org-variable-name">m_numerator</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_denominator</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Fraction</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
  <span class="org-function-name">Fraction</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">int</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_numerator<span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">)</span>, m_denominator<span class="org-rainbow-delimiters-depth-2">(</span>d<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; m_numerator &lt;&lt; <span class="org-string">"/"</span> &lt;&lt; m_denominator &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">Fraction</span>&amp; <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Fraction</span>&amp; <span class="org-variable-name">f</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    m_numerator = m_numerator * f.m_denominator + m_denominator * f.m_numerator;
    m_denominator *= f.m_denominator;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">Fraction</span>&amp; <span class="org-function-name">multiply</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Fraction</span>&amp; <span class="org-variable-name">f</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    m_numerator *= f.m_numerator;
    m_denominator *= f.m_denominator;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">Fraction</span>&amp; <span class="org-function-name">subtract</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Fraction</span>&amp; <span class="org-variable-name">f</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    m_numerator = m_numerator * f.m_denominator - m_denominator * f.m_numerator;
    m_denominator *= f.m_denominator;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Fraction</span> <span class="org-variable-name">f1</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  f1.add<span class="org-rainbow-delimiters-depth-2">(</span>Fraction<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">3</span>, <span class="org-highlight-numbers-number">8</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>.multiply<span class="org-rainbow-delimiters-depth-2">(</span>Fraction<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-highlight-numbers-number">2</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>.print<span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf23a339" class="outline-3">
<h3 id="orgf23a339"><span class="section-number-3">22.3.</span> Resetting Class Objects</h3>
<div class="outline-text-3" id="text-22-3">
<ul class="org-ul">
<li>We can do something like this to reset class type objects back to their default state-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">private</span>:
  <span class="org-type">int</span> <span class="org-variable-name">m_x</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_y</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-type">void</span> <span class="org-function-name">reset</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">reset the point object</span>
    *<span class="org-keyword">this</span> = Point<span class="org-rainbow-delimiters-depth-3">{}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdd3e573" class="outline-3">
<h3 id="orgdd3e573"><span class="section-number-3">22.4.</span> Classes and Header Files</h3>
<div class="outline-text-3" id="text-22-4">
<ul class="org-ul">
<li>Compilers need to see the full definition of class types in order to use them.</li>
<li>There&rsquo;s no &ldquo;forward declaration&rdquo; for class types.</li>
<li>Member functions CAN be forward declared like this-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Test</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">public</span>:
  <span class="org-type">void</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">void</span> <span class="org-constant">Test</span>::<span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">something</span>
  <span class="org-type">int</span> <span class="org-variable-name">x</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org530f53c" class="outline-3">
<h3 id="org530f53c"><span class="section-number-3">22.5.</span> Nested Types</h3>
<div class="outline-text-3" id="text-22-5">
<ul class="org-ul">
<li>Class types can have nested types like this-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Fruit</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>:
    <span class="org-keyword">enum</span> <span class="org-type">Type</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-variable-name">orange</span>, <span class="org-variable-name">apple</span>, <span class="org-variable-name">banana</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">private</span>:
    <span class="org-type">Type</span> <span class="org-variable-name">m_type</span> <span class="org-rainbow-delimiters-depth-2">{</span>orange<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">m_eaten</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Fruit</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
    <span class="org-function-name">Fruit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Type</span> <span class="org-variable-name">t</span>, <span class="org-type">bool</span> <span class="org-variable-name">eaten</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_type<span class="org-rainbow-delimiters-depth-2">{</span>t<span class="org-rainbow-delimiters-depth-2">}</span>, m_eaten<span class="org-rainbow-delimiters-depth-2">{</span>eaten<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>The enum Type has been made public and can be accessed via <code>Fruit::Type</code> and its enumerators can be accessed like this- <code>Fruit:apple</code>.</li>
<li>We&rsquo;ve used <code>enum</code> instead of <code>enum class</code> because classes have their own scope so we don&rsquo;t need to worry about polluting the global scope.</li>
<li>You can also use <code>typedef</code> and type aliases in a similar way to the above.</li>
</ul>
</div>
</div>
<div id="outline-container-org3272551" class="outline-3">
<h3 id="org3272551"><span class="section-number-3">22.6.</span> Destructors</h3>
<div class="outline-text-3" id="text-22-6">
<ul class="org-ul">
<li>When an object of a non-aggregated class type is destroyed, a special member function called the destructor is called automatically before hand.</li>
<li>Destructors, just like constructors, have special rules-
<ol class="org-ol">
<li>It should have the same name as that of the class <i>but</i> prefixed with a tilde <code>~</code>.</li>
<li>It cannot take any arguments.</li>
<li>It cannot return anything.</li>
</ol></li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Test</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">public</span>:
  <span class="org-function-name">Test</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Created object"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  ~<span class="org-function-name">Test</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Destroyed object"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Test</span> <span class="org-variable-name">t</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0f9b736" class="outline-3">
<h3 id="org0f9b736"><span class="section-number-3">22.7.</span> Class Templates with Member Functions</h3>
<div class="outline-text-3" id="text-22-7">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Pair</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">private</span>:
        <span class="org-type">T</span> <span class="org-variable-name">m_first</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
        <span class="org-type">T</span> <span class="org-variable-name">m_second</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">public</span>:
        <span class="org-function-name">Pair</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span> <span class="org-variable-name">first</span>, <span class="org-type">T</span> <span class="org-variable-name">second</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_first<span class="org-rainbow-delimiters-depth-2">{</span>first<span class="org-rainbow-delimiters-depth-2">}</span>, m_second<span class="org-rainbow-delimiters-depth-2">{</span>second<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Pair</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">p</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Since <code>T</code> might be expensive to copy, it&rsquo;s recommended to use <code>const T&amp;</code> for the constructor parameters.</li>
</ul>
</div>
</div>
<div id="outline-container-org19b2593" class="outline-3">
<h3 id="org19b2593"><span class="section-number-3">22.8.</span> Static Members</h3>
<div class="outline-text-3" id="text-22-8">
<ul class="org-ul">
<li>Static members of a class type in C++ are shared across all the objects instantiated from that class type.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">Test</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">test</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">initialize test to 1</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">because static members exist independently of the objects instantiated from the class type,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">they can be accessed anytime using the scope resolution operator</span>
<span class="org-type">int</span> <span class="org-constant">Test</span>::<span class="org-variable-name">test</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Test</span> <span class="org-variable-name">foo</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-type">Test</span> <span class="org-variable-name">bar</span><span class="org-rainbow-delimiters-depth-2">{}</span>;

    foo.test = <span class="org-highlight-numbers-number">2</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; bar.test &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Static members can be accessed even before any object is initialized.</li>
<li>When we declare a static member variable inside a class, it&rsquo;s like forward declaring it (but different).</li>
<li>You must explicitly define the global variables outside the class just like we&rsquo;re doing in the above example.</li>
<li>You should not instantiate static members inside header files, only put them in <code>.cpp</code> files, because if the header is included more than once, you&rsquo;ll get multiple definitions of the same variable (violation of ODR, compile error).</li>
</ul>
<blockquote>
<p>

</p>

<p>
You can also initialize static members inside the class definition itself but only if it&rsquo;s one of the following:
</p>
<ol class="org-ol">
<li>It is a <code>const</code> variable</li>
<li>It is a <code>constexpr</code> variable</li>
<li>It is an <code>inline</code> variable</li>
</ol>
</blockquote>
</div>
</div>
<div id="outline-container-org0b33c36" class="outline-3">
<h3 id="org0b33c36"><span class="section-number-3">22.9.</span> Static Member Functions</h3>
<div class="outline-text-3" id="text-22-9">
<ul class="org-ul">
<li>Member functions can also be defined as static. They can be used to make access functions for <b>private</b> member variables.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">class</span> <span class="org-type">Test</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">private</span>:
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">m_id</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">public</span>:
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_id;<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">defining static functions outside</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">no need to specify "static" here</span>
<span class="org-type">void</span> <span class="org-constant">Test</span>::<span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"hey"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">the function is being accessed without</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">Test</span>::getID<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">Test</span>::test<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Static member functions do not have a <code>*this</code> pointer because they&rsquo;re not associated with any object.</li>
</ul>
</div>
</div>
<div id="outline-container-org9e5bac6" class="outline-3">
<h3 id="org9e5bac6"><span class="section-number-3">22.10.</span> Friend Functions</h3>
<div class="outline-text-3" id="text-22-10">
<ul class="org-ul">
<li>A friend function is a function (may it be a member or a non-member function) that can access all private and protected members of a class as if it was a member of that class.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">private</span>:
        <span class="org-type">int</span> <span class="org-variable-name">m_x</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
        <span class="org-type">int</span> <span class="org-variable-name">m_y</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">public</span>:
        <span class="org-function-name">Point</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span> : m_x<span class="org-rainbow-delimiters-depth-2">{</span>x<span class="org-rainbow-delimiters-depth-2">}</span>, m_y<span class="org-rainbow-delimiters-depth-2">{</span>y<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;

        <span class="org-keyword">friend</span> <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Point</span>&amp; <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">the outsider function which is considered a "friend"</span>
<span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Point</span>&amp; <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; p.m_x &lt;&lt; <span class="org-string">","</span> &lt;&lt; p.m_y &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Point</span> <span class="org-variable-name">point</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">4</span>,<span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    print<span class="org-rainbow-delimiters-depth-2">(</span>point<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>You should prefer using non-friend functions over friend functions.</li>
<li>Friend functions don&rsquo;t have a <code>*this</code> pointer.</li>
</ul>
</div>
</div>
<div id="outline-container-org79ee19a" class="outline-3">
<h3 id="org79ee19a"><span class="section-number-3">22.11.</span> Friend Class</h3>
<div class="outline-text-3" id="text-22-11">
<ul class="org-ul">
<li>Similar to friend functions, a friend class can access private and protected members of another class.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">One</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">private</span>:
        <span class="org-type">int</span> <span class="org-variable-name">m_x</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">public</span>:
        <span class="org-function-name">One</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">making friends with Two :)</span>
        <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">Two</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">the friend class</span>
<span class="org-keyword">class</span> <span class="org-type">Two</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">public</span>:
        <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">One</span>&amp; <span class="org-variable-name">o</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; o.m_x &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">One</span> <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">{}</span>;

    <span class="org-constant">Two</span>::test<span class="org-rainbow-delimiters-depth-2">(</span>obj<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>If class A is a friend of B, it doesn&rsquo;t mean that class B is also a friend of A!</li>
</ul>
</div>
</div>
<div id="outline-container-orgfeeaa43" class="outline-3">
<h3 id="orgfeeaa43"><span class="section-number-3">22.12.</span> Ref Qualifiers</h3>
<div class="outline-text-3" id="text-22-12">
<ul class="org-ul">
<li>When returning values by reference or by value from member functions, we can get stuck in a difficult situation-
<ol class="org-ol">
<li>If the function returns by value (rvalue), it can be used safely anywhere but might be inefficient to copy.</li>
<li>If the function returns by reference (lvalue), it&rsquo;s faster but can result in undefined behaviour (if the obj is destroyed).</li>
</ol></li>
<li>We can overload functions in C++ classes to specify different behaviour based on the context (one where implicit object is an lvalue and another one in which the implicit object is an rvalue).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">//  </span><span class="org-comment">&amp; qualifier overloads function to match only lvalue implicit objects, returns by reference</span>
<span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> &amp; <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> m_name; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&amp;&amp; qualifier overloads function to match only rvalue implicit objects, returns by value</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> &amp;&amp; <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> m_name; <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<blockquote>
<p>

</p>

<p>
Use of ref qualifiers is not recommended for a few reasons-
</p>
<ol class="org-ol">
<li>Most developers don&rsquo;t know about this so this can cause errors or inefficiencies in use.</li>
<li>Use of this can be prevented easily by using good practices.</li>
</ol>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org42c9673" class="outline-2">
<h2 id="org42c9673"><span class="section-number-2">23.</span> Vectors</h2>
<div class="outline-text-2" id="text-23">
<ul class="org-ul">
<li><code>std::vector</code> is one of the container classes in C++ that implements an array.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">specifying the type</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">nums</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">2</span>,<span class="org-highlight-numbers-number">3</span>,<span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">type deduction based on CTAD (preferred)</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span> <span class="org-variable-name">vowels</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">'a'</span>, <span class="org-string">'e'</span>, <span class="org-string">'i'</span>, <span class="org-string">'o'</span>, <span class="org-string">'u'</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>The container classes use a special type of constructor called the &ldquo;list constructor&rdquo; to initialize the elements.</li>
<li>Passing an invalid index to <code>operator[]</code> to access elements will cause undefined behaviour since this operator does not do any checking.</li>
</ul>
</div>
<div id="outline-container-org17279a1" class="outline-3">
<h3 id="org17279a1"><span class="section-number-3">23.1.</span> Constructing arrays of specific length</h3>
<div class="outline-text-3" id="text-23-1">
<ul class="org-ul">
<li><code>std::vector</code> has a constructor for this- <code>explicit std::vector&lt;T&gt;(int)</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">zeroes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this will create an array of 10 zeroes (value initialized)</span>
</pre>
</div>
<ul class="org-ul">
<li>This constructor <i>must</i> be called using direct initialization and <b>not</b> direct-list initialization.</li>
</ul>
</div>
</div>
<div id="outline-container-org30dcf19" class="outline-3">
<h3 id="org30dcf19"><span class="section-number-3">23.2.</span> <code>const</code> and <code>constexpr</code> vectors</h3>
<div class="outline-text-3" id="text-23-2">
<ul class="org-ul">
<li>Vectors can be made <code>const</code>, and such vectors can&rsquo;t be modified later.</li>
<li><code>const</code> vectors must be initialized.</li>
<li>Non-const vectors can NOT contain const values so something like this won&rsquo;t compile: <code>std::vector&lt;const int&gt; nums {1,2,3,4};</code></li>
<li>Vectors can <b>not</b> be made <code>constexpr</code>. You can use <code>std::array</code> for that.</li>
</ul>
</div>
</div>
<div id="outline-container-org3b08061" class="outline-3">
<h3 id="org3b08061"><span class="section-number-3">23.3.</span> Size of a vector</h3>
<div class="outline-text-3" id="text-23-3">
<ul class="org-ul">
<li>You can get the number of elements in a vector by using the <code>size()</code> member function of the vector object.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span> <span class="org-variable-name">nums</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">2</span>,<span class="org-highlight-numbers-number">3</span>,<span class="org-highlight-numbers-number">4</span>,<span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; nums.size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<ul class="org-ul">
<li>You can also use the <b>non-member</b> function <code>std::size</code> to get the size of any type of array: <code>std::size(myArr)</code>.</li>
<li>C++20 introduced a non-member <code>std::ssize</code> function which returns the size of an array as a <b>signed</b> type.</li>
</ul>
</div>
</div>
<div id="outline-container-org6a2cd5c" class="outline-3">
<h3 id="org6a2cd5c"><span class="section-number-3">23.4.</span> Accessing elements of a vector</h3>
<div class="outline-text-3" id="text-23-4">
<ul class="org-ul">
<li>When we use <code>operator[]</code> to access elements of an array, there&rsquo;s no bound checking. Accessing non existing indices leads to undefined behaviour.</li>
<li>We can use the <code>.at()</code> member function to access elements with runtime bounds checking.</li>
<li>We can use <code>constexpr int</code> variables to access elements without getting narrowing conversion warnings (because <code>std::size_t</code> is required).</li>
<li>We should use <code>std::size_t</code> for iterations and accessing elements but this is an unsigned type and might not always be desirable..</li>
<li>If we want, we can use <code>int</code> or <code>std::ptrdiff_t</code> (when the number of elements is large) to access elements.</li>
</ul>
</div>
</div>
<div id="outline-container-orgbae3d85" class="outline-3">
<h3 id="orgbae3d85"><span class="section-number-3">23.5.</span> Passing Vectors</h3>
<div class="outline-text-3" id="text-23-5">
<ul class="org-ul">
<li>When passing vectors to functions, their full type must be speficied-</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">myVector</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
<ul class="org-ul">
<li>We prefer passing them by reference.</li>
</ul>
</div>
</div>
<div id="outline-container-org487c571" class="outline-3">
<h3 id="org487c571"><span class="section-number-3">23.6.</span> Move Semantics</h3>
<div class="outline-text-3" id="text-23-6">
<ul class="org-ul">
<li>These are the rules which determine how the data from one object is moved to another object.</li>
<li>Moving data, i.e., transferring ownership, to other objects is much faster than copying it.</li>
<li>When move semantics is invoked, any data that can be moved is moved while others are copied.</li>
<li><code>std::string</code> and <code>std::vector</code>, both support move semantics, so they CAN be safely passed by VALUE!!!</li>
<li>Move semantics are invoked automatically for supported types.</li>
</ul>
</div>
</div>
<div id="outline-container-orgac7efbc" class="outline-3">
<h3 id="orgac7efbc"><span class="section-number-3">23.7.</span> Range Based For Loop</h3>
<div class="outline-text-3" id="text-23-7">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span> <span class="org-variable-name">nums</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-highlight-numbers-number">1</span>,<span class="org-highlight-numbers-number">2</span>,<span class="org-highlight-numbers-number">3</span>,<span class="org-highlight-numbers-number">4</span>,<span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">CTAD to deduce type of template parameter</span>

    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">num</span> : nums<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; num &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>We should use the <code>auto</code> keyword to deduce the type in the loop.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Prayag Jain</p>
<p class="date">Created: 2024-03-05 Tue 20:26</p>
</div>
</body>
</html>
